{"version":3,"sources":["webpack://FRON/webpack/universalModuleDefinition","webpack://FRON/webpack/bootstrap","webpack://FRON/./node_modules/get-value/index.js","webpack://FRON/./node_modules/literal-toolkit/lib/util.js","webpack://FRON/./src/types.ts","webpack://FRON/./node_modules/isobject/index.js","webpack://FRON/./node_modules/literal-toolkit/index.js","webpack://FRON/./node_modules/safe-string-literal/index.js","webpack://FRON/./node_modules/literal-toolkit/lib/keyword.js","webpack://FRON/./src/util.ts","webpack://FRON/./src/index.ts","webpack://FRON/./src/stringify.ts","webpack://FRON/./node_modules/literal-toolkit/lib/string.js","webpack://FRON/./node_modules/literal-toolkit/lib/number.js","webpack://FRON/./node_modules/literal-toolkit/lib/regexp.js","webpack://FRON/./node_modules/literal-toolkit/lib/comment.js","webpack://FRON/external \"assert\"","webpack://FRON/./src/parse.ts","webpack://FRON/./node_modules/set-value/index.js","webpack://FRON/./node_modules/is-plain-object/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isObject","join","segs","joinChar","options","isValid","target","isValidObject","val","Array","isArray","path","default","String","isString","splitChar","separator","split","len","length","idx","prop","slice","hasProp","BOUNDARIES","strictMatch","str","token","boundaries","arguments","leftOver","offset","test","util_1","IsNode","global","Variable","CompoundTypes","getType","data","undefined","ctor","type","getInstance","FRONEntryBase","[object Object]","assign","FRONString","checkProto","proto","fromFRON","TypeError","checkType","ReferenceError","copyProto","source","pick","register","Error","constructor","keyFor","for","Number","Boolean","forEach","valueOf","RegExp","toString","flags","Date","toISOString","Map","Set","values","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","from","EvalError","RangeError","SyntaxError","reserved","omit","defineProperties","writable","configurable","message","stack","AssertionError","Buffer","string","number","keyword","regexp","comment","escape","excludes","replace","char","indexOf","unescape","chars","KEYWORDS","parseToken","match","exec","parse","toLiteral","keys","obj","getPrototypeOf","Reflect","ownKeys","concat","filter","pass","arr","iterator","item","push","props","result","stringify_1","stringify","parse_1","composeToken","SourceToken","types_1","literal_toolkit_1","stringifyCommon","indent","originalIndent","refMap","getHandler","has","set","handlers","container","toFRON","x","isVar","res","handler","apply","pretty","SINGLE_QUOTE","DOUBLE_QUOTE","BACK_QUOTE","quote","matches","skippedLength","removeUnusedEscapes","exclues","NUM_SEQUENCE","allowTrailings","NaN","radix","_token","_char","toLowerCase","pos","b","prevChar","parseInt","isNaN","strict","isRadix","BIN","OCT","DEC","HEX","isBin","isOct","isDec","isHex","isFinite","num","Infinity","2","8","10","16","FLAGS","closed","e","re","INLINE_COMMENT","MULTI_LINE_COMMENT","strip","lines","isNewLine","unshift","require","TypeOrPorp","throwSyntaxError","filename","line","column","position","start","normalizePath","parts","sep","process","platform","splice","last","compose","parent","handle","inst","ref","listener","doParseToken","cursor","loop","index","remains","dataToken","end","console","log","comments","prefix","isPlain","opts","merge","id","pattern","createKey","memo","orig","isObjectObject","prot"],"mappings":"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","file":"fron.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FRON\"] = factory();\n\telse\n\t\troot[\"FRON\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","/*!\n * get-value <https://github.com/jonschlinkert/get-value>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isObject = require('isobject');\n\nmodule.exports = function(target, path, options) {\n  if (!isObject(options)) {\n    options = { default: options };\n  }\n\n  if (!isValidObject(target)) {\n    return typeof options.default !== 'undefined' ? options.default : target;\n  }\n\n  if (typeof path === 'number') {\n    path = String(path);\n  }\n\n  const isArray = Array.isArray(path);\n  const isString = typeof path === 'string';\n  const splitChar = options.separator || '.';\n  const joinChar = options.joinChar || (typeof splitChar === 'string' ? splitChar : '.');\n\n  if (!isString && !isArray) {\n    return target;\n  }\n\n  if (isString && path in target) {\n    return isValid(path, target, options) ? target[path] : options.default;\n  }\n\n  let segs = isArray ? path : split(path, splitChar, options);\n  let len = segs.length;\n  let idx = 0;\n\n  do {\n    let prop = segs[idx];\n    if (typeof prop === 'number') {\n      prop = String(prop);\n    }\n\n    while (prop && prop.slice(-1) === '\\\\') {\n      prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options);\n    }\n\n    if (prop in target) {\n      if (!isValid(prop, target, options)) {\n        return options.default;\n      }\n\n      target = target[prop];\n    } else {\n      let hasProp = false;\n      let n = idx + 1;\n\n      while (n < len) {\n        prop = join([prop, segs[n++]], joinChar, options);\n\n        if ((hasProp = prop in target)) {\n          if (!isValid(prop, target, options)) {\n            return options.default;\n          }\n\n          target = target[prop];\n          idx = n - 1;\n          break;\n        }\n      }\n\n      if (!hasProp) {\n        return options.default;\n      }\n    }\n  } while (++idx < len && isValidObject(target));\n\n  if (idx === len) {\n    return target;\n  }\n\n  return options.default;\n};\n\nfunction join(segs, joinChar, options) {\n  if (typeof options.join === 'function') {\n    return options.join(segs);\n  }\n  return segs[0] + joinChar + segs[1];\n}\n\nfunction split(path, splitChar, options) {\n  if (typeof options.split === 'function') {\n    return options.split(path);\n  }\n  return path.split(splitChar);\n}\n\nfunction isValid(key, target, options) {\n  if (typeof options.isValid === 'function') {\n    return options.isValid(key, target);\n  }\n  return true;\n}\n\nfunction isValidObject(val) {\n  return isObject(val) || Array.isArray(val) || typeof val === 'function';\n}\n","var BOUNDARIES = /^\\s*[,;)\\]}\\/]|^\\s*$/;\n\nexports.strictMatch = strictMatch;\n/**\n * @param {string} str \n * @param {{ offset: number, length: number }} token \n */\nfunction strictMatch(str, token) {\n    var boundaries = arguments[2] || BOUNDARIES;\n    var leftOver = str.slice(token.offset + token.length);\n    return !leftOver || boundaries.test(leftOver);\n}","import get = require(\"get-value\");\nimport { pick, omit, values } from \"./util\";\n\n/**\n * The interface restricts if a user defined type can be registered as FRON type.\n */\nexport interface FRONEntry {\n    toFRON?(): any;\n    fromFRON(data: any): any;\n};\n\n/** Indicates a class constructor that implements the FRONEntry interface. */\nexport type FRONConstructor = new (...args: any[]) => FRONEntry;\n\n/** Whether the current environment is NodeJS. */\nexport const IsNode = typeof global === \"object\"\n    && get(global, \"process.release.name\") === \"node\";\n\n/** The pattern that matches valid JavaScript Latin variable names. */\nexport const Variable = /^[a-z_][a-z0-9_]*$/i;\n\n/** \n * Stores all supported compound types, includes the types that user registered.\n */\nexport const CompoundTypes: { [type: string]: FRONConstructor } = {\n    // objects and arrays are handled internally by the stringifier and parser,\n    // register here is for checkers to identify them as compound types.\n    Object: <any>Object,\n    Array: <any>Object\n};\n\n/**\n * Gets the type name in string of the input data, may return a literal type \n * or a compound type.\n */\nexport function getType(data: any): string {\n    if (data === undefined) {\n        return;\n    } else if (data === null) {\n        return \"null\";\n    } else {\n        let type = typeof data,\n            ctor: FRONConstructor;\n\n        if (type !== \"object\") {\n            return type === \"symbol\" ? \"Symbol\" : type;\n        } else if (ctor = get(data, \"constructor\")) {\n            for (let type in CompoundTypes) {\n                if (ctor === CompoundTypes[type])\n                    return type;\n            }\n\n            return ctor.name;\n        }\n    }\n}\n\n/**\n * Gets an instance of the given type, may return undefined if the type isn't \n * registered, this function calls `Object.create()` to create instance, so the\n * constructor will not be called automatically.\n * \n * NOTE: This function may return `undefined` if the given type isn't registered.\n */\nexport function getInstance<T = any>(\n    type: string | (new (...args: any[]) => T)\n): T {\n    type = typeof type === \"function\" ? type.name : type;\n    return CompoundTypes[type] && Object.create(CompoundTypes[type].prototype);\n}\n\n/**\n * When register a type with an object as its prototype, a new sub-class will \n * be created to extend FRONEntryBase and merge the object to its prototype. In \n * the parsing phase, a FRONEntryBase instance will be created via \n * `Object.create()` and apply the `fromFRON()` method to it.\n */\nexport class FRONEntryBase implements FRONEntry {\n    toFRON() {\n        return Object.assign({}, this);\n    }\n\n    fromFRON(data: any) {\n        return data;\n    }\n}\n\n/**\n * A special type used to mark up user defined FRON notations, if a `toFRON()`\n * method return a `FRONString`, them it will not be stringified again with\n * common approach, just use the represented value as the output notation.\n * NOTE: the personalized notation must use valid syntax that can be identified \n * by the parser, it is either a literal, or a compound type.\n */\nexport class FRONString extends String { }\n\n/** Checks if the given prototype can be registered as an FRON type. */\nfunction checkProto(name: string, proto: FRONEntry) {\n    if (typeof proto.fromFRON !== \"function\") {\n        // Every constructor that used as FRON type should include a \n        // `fromFRON()` method, so that when parsing the FRON string, the parser\n        // could call the method to produce an expected instance of the type.\n        throw new TypeError(`prototype method ${name}.fromFRON() is missing`);\n    } else if (proto.fromFRON.length < 1) {\n        // The `fromFRON()` method needs to accept at least one argument, which \n        // is the data parsed from the FRON string, usually used to create a new\n        // instance of the type.\n        // The second argument `type` is optional, when pass, it is the type \n        // notation in string of the token.\n        throw new TypeError(`prototype method ${name}.fromFRON() is invalid`);\n    }\n}\n\n/** Checks if a type is registered. */\nfunction checkType(type: string | FRONConstructor) {\n    type = typeof type === \"string\" ? type : type.name;\n    if (!CompoundTypes[type]) {\n        throw new ReferenceError(`Unrecognized type: ${type}`);\n    }\n}\n\n/**\n * Copies the FRONEntry protocol methods from a FRONConstructor to another \n * constructor.\n */\nfunction copyProto(source: object | FRONConstructor, target: Function) {\n    source = typeof source === \"function\" ? source.prototype : source;\n    Object.assign(target.prototype, pick(source, [\n        \"toFRON\",\n        \"fromFRON\"\n    ]));\n}\n\n/**\n * Registers a customized data type so that the stringifier and parser can \n * identify it.\n * @example\n *  // Register a constructor with `toFRON` and `fromFRON` methods.\n *  register(User);\n * \n *  // Register a constructor and merger a customized prototype.\n *  register(Date, { toFRON() { ... }, fromFRON() { ... } });\n * \n *  // Register a non-constructor type with a customized prototype.\n *  register(\"Article\", { toFRON() { ... }, fromFRON() { ... } });\n * \n *  // Four ways to register an alias type.\n *  // NOTE: the former two will use the constructor `Student`\n *  // to create instance when parsing, but the last two will\n *  // use `User` since \"Student\" is not a constructor. However,\n *  // they all use the name \"Student\" as notation.\n *  register(Student, User);\n *  register(Student, \"User\");\n *  register(\"Student\", User);\n *  register(\"Student\", \"User\");\n */\nexport function register(\n    type: string | FRONConstructor | (new (...args: any[]) => any),\n    proto?: string | FRONConstructor | FRONEntry\n): void {\n    if (typeof type === \"function\") {\n        if (!proto) {\n            checkProto(type.name, type.prototype);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"string\") {\n            checkType(proto);\n            copyProto(CompoundTypes[proto], type);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"function\") {\n            checkProto(proto.name, proto.prototype);\n            copyProto(proto, type);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"object\") {\n            checkProto(type.name, proto);\n            copyProto(proto, type);\n            CompoundTypes[type.name] = type;\n        } else {\n            throw new Error(`Invalid prototype: ${proto}`);\n        }\n    } else if (typeof type === \"string\") {\n        if (typeof proto === \"string\") {\n            checkType(proto);\n            CompoundTypes[type] = CompoundTypes[proto];\n        } else if (typeof proto === \"function\") {\n            checkProto(proto.name, proto.prototype);\n            CompoundTypes[type] = proto;\n        } else if (typeof proto === \"object\") {\n            checkProto(type, proto);\n            let ctor: Function = proto.constructor;\n\n            if (ctor === Object)\n                ctor = class extends FRONEntryBase { };\n\n            copyProto(proto, ctor);\n            CompoundTypes[type] = <any>ctor;\n        } else {\n            throw new Error(`Invalid prototype: ${proto}`);\n        }\n    } else {\n        throw new TypeError(`Invalid type: ${type}`);\n    }\n}\n\n// Register handler for Symbol.\nregister(<any>Symbol, {\n    toFRON(this: symbol) {\n        return Symbol.keyFor(this);\n    },\n    fromFRON(data: string) {\n        return Symbol.for(data);\n    }\n});\n\n// Register handlers for Number, Boolean, String.\n[Number, Boolean, String].forEach(type => {\n    register(type, {\n        toFRON(this: String | Number | Boolean) {\n            return this.valueOf();\n        },\n        fromFRON(data: any) {\n            return new (<any>this.constructor)(data);\n        }\n    });\n});\n\n// Register handler for RegExp.\nregister(RegExp, {\n    toFRON(this: RegExp) {\n        return new FRONString(this.toString());\n    },\n    fromFRON(data: { source: string, flags: string }) {\n        // For FRON string to support object wrapped by RegExp, and literal is \n        // internally support by the parser.\n        return new (<any>this.constructor)(data.source, data.flags);\n    }\n});\n\n// Register handler for Date.\nregister(Date, {\n    toFRON(this: Date) {\n        return this.toISOString();\n    },\n    fromFRON(data: string) {\n        return new (<any>this.constructor)(data);\n    }\n});\n\n// Register handlers for Map and Set.\n[Map, Set].forEach(type => {\n    register(type, {\n        toFRON(this: Iterable<any>) {\n            return values(this);\n        },\n        fromFRON(data: any[]) {\n            return new (<any>this.constructor)(data);\n        }\n    });\n});\n\n// Register handlers for typed arrays.\n[\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array\n].forEach(type => {\n    register(type, {\n        toFRON(this: Iterable<number>) {\n            return values(this);\n        },\n        fromFRON(data: number[]) {\n            return (<any>this.constructor).from(data);\n        }\n    });\n});\n\n// Register handlers for all errors.\n[\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError\n].forEach(type => {\n    register(type, {\n        toFRON(this: Error) {\n            // When stringify an error, stringify all its member properties,\n            // include `name`, `message` and `stack`, since they may not be \n            // enumerated, so using `pick()` to fetch them manually.\n            let reserved = [\"name\", \"message\", \"stack\"];\n\n            return Object.assign({}, pick(this, reserved), omit(this, reserved));\n        },\n        fromFRON(this: Error, data: { [x: string]: any }) {\n            Object.defineProperties(this, {\n                name: {\n                    value: data.name,\n                    writable: true,\n                    configurable: true\n                },\n                message: {\n                    value: data.message,\n                    writable: true,\n                    configurable: true\n                },\n                stack: {\n                    value: data.stack,\n                    writable: true,\n                    configurable: true\n                }\n            });\n            Object.assign(this, omit(data, [\"name\", \"message\", \"stack\"]));\n\n            return this;\n        }\n    });\n});\n\nif (IsNode) {\n    // Register some well-known NodeJS types.\n    let AssertionError: FRONConstructor = require(\"assert\").AssertionError;\n    register(AssertionError, Error.name);\n    register(Buffer, Uint8Array.name);\n}","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nexports.string = require(\"./lib/string\");\nexports.number = require(\"./lib/number\");\nexports.keyword = require(\"./lib/keyword\");\nexports.regexp = require(\"./lib/regexp\");\nexports.comment = require(\"./lib/comment\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * @param {string} str \n * @param {string|string[]} excludes \n */\nfunction escape(str, excludes) {\n    return String(str).replace(/[\"'`\\\\\\b\\f\\n\\r\\t\\u2028\\u2029]/g, function (char) {\n        if (excludes && excludes.indexOf(char) >= 0)\n            return char;\n\n        switch (char) {\n            case '\"':\n            case \"'\":\n            case '`':\n            case \"\\\\\":\n                return \"\\\\\" + char;\n            case \"\\b\":\n                return \"\\\\b\";\n            case \"\\f\":\n                return \"\\\\f\";\n            case \"\\n\":\n                return \"\\\\n\";\n            case \"\\r\":\n                return \"\\\\r\";\n            case \"\\t\":\n                return \"\\\\t\";\n            case \"\\u2028\":\n                return \"\\\\u2028\";\n            case \"\\u2029\":\n                return \"\\\\u2029\";\n        }\n    });\n}\n\n/**\n * @param {string} str \n */\nfunction unescape(str) {\n    return String(str).replace(/\\\\[\"'`\\\\bfnrt]|\\\\u2028|\\\\u2029/g, function (chars) {\n        switch (chars) {\n            case '\\\\\"':\n            case \"\\\\'\":\n            case \"\\\\`\":\n            case \"\\\\\\\\\":\n                return chars[1];\n            case \"\\\\b\":\n                return \"\\b\";\n            case \"\\\\f\":\n                return \"\\f\";\n            case \"\\\\n\":\n                return \"\\n\";\n            case \"\\\\r\":\n                return \"\\r\";\n            case \"\\\\t\":\n                return \"\\t\";\n            case \"\\\\u2028\":\n                return \"\\u2028\";\n            case \"\\\\u2029\":\n                return \"\\u2029\";\n        }\n    });\n}\n\nexports.escape = escape;\nexports.unescape = unescape;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar KEYWORDS = /^\\s*(true|false|null|NaN|Infinity)(\\s*[,;)\\]}]|\\s*$)/;\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: true | false | null | NaN | Infinity }} \n */\nfunction parseToken(str) {\n    var match = KEYWORDS.exec(str);\n\n    if (match) {\n        var value;\n\n        switch (match[1]) {\n            case \"true\":\n                value = true;\n                break;\n            case \"false\":\n                value = false;\n                break;\n            case \"NaN\":\n            case \"Infinity\":\n                value = Number(match[1]);\n                break;\n            default:\n                value = null;\n                break;\n        }\n\n        return {\n            source: match[1],\n            offset: str.indexOf(match[1]),\n            length: match[1].length,\n            value: value\n        };\n    } else {\n        return null;\n    }\n}\n\n/**\n * @param {string} str \n */\nexports.parse = function parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n};\n\n/**\n * @param {true | false | null | NaN | Infinity} keyword\n */\nexports.toLiteral = function toLiteral(keyword) {\n    return String(keyword);\n};","/**\n * Gets all properties of an object, including those inherited from prototype.\n */\nexport function keys(obj: any) {\n    let proto = Object.getPrototypeOf(obj);\n\n    return Reflect.ownKeys(obj).concat(\n        Reflect.ownKeys(proto).filter(key => {\n            if (typeof key === \"string\" && key.slice(0, 1) === \"__\") {\n                return false;\n            } else {\n                let pass = false;\n\n                try {\n                    pass = typeof proto[key] !== \"function\";\n                } finally {\n                    return pass;\n                }\n            }\n        })\n    );\n}\n\n/** Gets the values in the given iterable object. */\nexport function values<T>(data: Iterable<T> | { [x: string]: T }) {\n    let arr: T[] = [];\n\n    if (typeof data[Symbol.iterator] === \"function\") {\n        for (let item of (<Iterable<T>>data)) {\n            arr.push(item);\n        }\n    } else {\n        for (let key of keys(data)) {\n            arr.push(data[key]);\n        }\n    }\n\n    return arr;\n}\n\n/** Gets a copy of an object with only the specified keys. */\nexport function pick(obj: any, props: (string | number | symbol)[]): any {\n    let result = {};\n\n    for (let key of keys(obj)) {\n        if (props.indexOf(key) >= 0) {\n            result[key] = obj[key];\n        }\n    }\n\n    return result;\n}\n\n/** Gets a copy of an object without the specified keys. */\nexport function omit(obj: any, props: (string | number | symbol)[]): any {\n    let result = {};\n\n    for (let key of keys(obj)) {\n        if (props.indexOf(key) === -1) {\n            result[key] = obj[key];\n        }\n    }\n\n    return result;\n}","import { stringify } from \"./stringify\";\nimport { parse, parseToken, composeToken, SourceToken } from \"./parse\";\nimport {\n    register,\n    FRONEntry,\n    FRONEntryBase,\n    FRONConstructor,\n    FRONString,\n    getType,\n    getInstance\n} from \"./types\";\n\nexport {\n    register,\n    stringify,\n    parse,\n    parseToken,\n    composeToken,\n    SourceToken,\n    FRONEntry,\n    FRONEntryBase,\n    FRONConstructor,\n    FRONString,\n    getType,\n    getInstance\n};","import get = require(\"get-value\");\nimport { string } from \"literal-toolkit\";\nimport {\n    Variable,\n    CompoundTypes,\n    FRONString,\n    getType,\n} from './types';\n\n/** Stringifies any type of data in a common way. */\nfunction stringifyCommon(\n    data: any,\n    indent: string,\n    originalIndent: string,\n    path: string,\n    refMap: Map<any, string>\n): string {\n    let type = getType(data);\n\n    if (!type || type == \"function\") {\n        return;\n    } else if (type == \"null\") {\n        return type;\n    } else if (type == \"string\") {\n        return string.toLiteral(data);\n    } else if (type == \"Symbol\") {\n        return getHandler(type, indent, originalIndent, path, refMap)(data);\n    } else if (typeof data === \"object\") {\n        if (refMap.has(data)) {\n            // `Reference` is a special type in FRON, it indicates that the \n            // current property references to another property, they are \n            // `aliases` to each other. When stringifing, the first reached \n            // property will be transferred as usual, but other properties that \n            // reference to this property will only be notate as an `Reference` \n            // with the original path, and the parser can use that path to set\n            // property when parsing.\n            return \"Reference(\" + stringify(refMap.get(data)) + \")\";\n        } else {\n            refMap.set(data, path);\n            return getHandler(type, indent, originalIndent, path, refMap)(data);\n        }\n    } else {\n        return String(data);\n    }\n}\n\n/** Gets the handler to stringify the corresponding compound type. */\nfunction getHandler(\n    type: string,\n    indent: string,\n    originalIndent: string,\n    path: string,\n    refMap: Map<any, string>\n): (data: any) => string {\n    var handlers = {\n        \"Object\": (data: any) => {\n            let container: string[] = [];\n\n            if (typeof data.toFRON == \"function\") {\n                // If the given object includes a `toFRON()` method, call it and\n                // get the returning value as the data to be stringified.\n                data = data.toFRON();\n            }\n\n            if (data === undefined) return;\n\n            // Stringify all enumerable properties of the object.\n            for (let x in data) {\n                let isVar = Variable.test(x),\n                    prop = isVar ? x : `['${x}']`,\n                    res = stringifyCommon(\n                        data[x],\n                        indent + originalIndent,\n                        originalIndent,\n                        path + (isVar && path ? \".\" : \"\") + prop,\n                        refMap\n                    );\n\n                if (res === undefined)\n                    continue; // If the result returns undefined, skip it.\n                else if (indent)\n                    container.push((isVar ? x : stringify(x)) + `: ${res}`);\n                else\n                    container.push((isVar ? x : stringify(x)) + `:${res}`);\n            }\n\n            if (indent && container.length) { // use indentation\n                return \"{\\n\"\n                    + indent + container.join(\",\\n\" + indent) + \"\\n\"\n                    + indent.slice(0, -originalIndent.length) + \"}\";\n            } else {\n                return \"{\" + container.join(\",\") + \"}\";\n            }\n        },\n        \"Array\": (data: any[]) => {\n            let container: string[] = [];\n\n            // Only stringify iterable elements of the array.\n            for (let i = 0; i < data.length; i++) {\n                let res = stringifyCommon(\n                    data[i],\n                    indent + originalIndent,\n                    originalIndent,\n                    `${path}[${i}]`,\n                    refMap\n                );\n\n                // skip undefined result\n                (res !== undefined) && container.push(res);\n            }\n\n            if (indent && container.length) { // use indentation\n                return \"[\\n\"\n                    + indent + container.join(\",\\n\" + indent) + \"\\n\"\n                    + indent.slice(0, -originalIndent.length) + \"]\";\n            } else {\n                return \"[\" + container.join(\",\") + \"]\";\n            }\n        },\n    };\n\n    if (handlers[type]) {\n        return handlers[type];\n    } else {\n        return (data: any) => {\n            let handler: Function;\n\n            if (typeof data.toFRON == \"function\") {\n                // If the given object includes a `toFRON()` method, call it and\n                // get the returning value as the data to be stringified.\n                data = data.toFRON();\n            } else if (handler = get(CompoundTypes[type], \"prototype.toFRON\")) {\n                // If there is a customized handler registered to deal with the \n                // type, apply it to the data. The reason to call `apply()` \n                // instead of calling the method directly is that the handler \n                // method may not exist on the data instance, it may be \n                // registered with an object as prototype in the first place.\n                data = handler.apply(data);\n            } else {\n                // If no handler is found, stringify the data as an ordinary \n                // object with only its enumerable properties.\n                data = Object.assign({}, data);\n            }\n\n            if (data === undefined) {\n                return;\n            } else if (data instanceof FRONString) {\n                return data.valueOf();\n            } else {\n                return type + \"(\" + stringifyCommon(\n                    data,\n                    indent,\n                    originalIndent,\n                    path,\n                    refMap\n                ) + \")\";\n            }\n        }\n    }\n}\n\n/**\n * Stringifies the given data into a FRON string.\n * @param pretty The default indentation is two spaces, other than that, set \n *  any strings for indentation is allowed.\n */\nexport function stringify(data: any, pretty?: boolean | string): string {\n    let indent = \"\";\n\n    if (pretty) {\n        indent = typeof pretty == \"string\" ? pretty : \"  \";\n    }\n\n    return stringifyCommon(data, indent, indent, \"\", new Map<any, string>());\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\nvar escape = exports.escape = require(\"safe-string-literal\").escape;\nvar unescape = exports.unescape = require(\"safe-string-literal\").unescape;\n\nvar SINGLE_QUOTE = exports.SINGLE_QUOTE = \"'\";\nvar DOUBLE_QUOTE = exports.DOUBLE_QUOTE = '\"';\nvar BACK_QUOTE = exports.BACK_QUOTE = \"`\";\n\n/**\n * @param {string} str \n */\nfunction removeUnusedEscapes(str) {\n    var exludes = \"\\\\'\\\"`bfnrtux\";\n    return String(str).replace(/\\\\\\S/g, function (chars) {\n        if (!~exludes.indexOf(chars[1])) {\n            return chars[1];\n        } else {\n            return chars;\n        }\n    });\n}\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: string, quote: \"'\" | \"\\\"\" | \"`\" }} \n */\nfunction parseToken(str) {\n    var token = { source: \"\", offset: -1, length: 0, value: \"\", quote: \"\" };\n    var matches = \"\";\n    var skippedLength = 0;\n\n    for (var i = 0; i < str.length; i++) {\n        var char = str[i];\n\n        if (char != false || token.quote) {\n            if (token.offset === -1) {\n                token.offset = i;\n            }\n\n            token.source += char;\n\n            if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE || char === BACK_QUOTE) {\n                matches += char;\n\n                if (!token.quote) {\n                    token.quote = char;\n                } else if (char === token.quote && str[i - 1] !== \"\\\\\") {\n                    break;\n                }\n            } else if (char === \"\\\\\") {\n                if (str[i + 1] === \"\\n\") {\n                    token.source += \"\\n\";\n                    skippedLength += 2;\n                    i++; // skip new line character of the string\n                } else {\n                    matches += char;\n                }\n            } else if (char === \"\\n\") {\n                if (token.quote === BACK_QUOTE) {\n                    matches += char;\n                } else if (str[i - 1] !== \"\\\\\") {\n                    return null;\n                } else {\n                    matches = matches.slice(0, -1);\n                    matches += char;\n                }\n            } else if (char !== \"\\n\" && token.quote) {\n                matches += char;\n            } else {\n                return null;\n            }\n        }\n    }\n\n    // token.source = matches;\n    token.value = matches && unescape(removeUnusedEscapes(matches.slice(1, -1)));\n    token.length = matches.length + skippedLength;\n    token.offset = token.offset === -1 ? 0 : token.offset;\n\n    if (strictMatch(str, token, /^\\s*[,;:)\\]}\\/]|^\\s*$/)) {\n        return token;\n    } else {\n        return null;\n    }\n}\n\nexports.parse = parse;\n/**\n * @param {string} str \n */\nfunction parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n}\n\nexports.toLiteral = toLiteral;\n/**\n * @param {string} str \n * @param {\"'\" | \"\\\"\" | \"`\"} quote \n */\nfunction toLiteral(str, quote) {\n    var exclues;\n    quote = quote || '\"';\n\n    if (quote === \"'\")\n        exclues = '\"`';\n    else if (quote === '\"')\n        exclues = \"'`\";\n    else if (quote === \"`\")\n        exclues = \"'\\\"\\n\";\n\n    return quote + escape(str, exclues) + quote;\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\nvar keyword = require(\"./keyword\");\n\nvar NUM_SEQUENCE = \"0123456789abcdefox-+.\";\n\nexports.BIN = 2;\nexports.OCT = 8;\nexports.DEC = 10;\nexports.HEX = 16;\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @param {boolean} allowTrailings\n * @returns {{ source: string, offset: number, length: number, value: number, radix: 8 | 10 | 16 }} \n */\nfunction parseToken(str) {\n    var allowTrailings = arguments[1] || false;\n    var matches = \"\";\n    var token = { source: \"\", offset: -1, length: 0, value: NaN, radix: 0 };\n    var _token = keyword.parseToken(str);\n\n    if (_token) {\n        token = Object.assign(_token, { radix: 10 });\n\n        if (typeof token.value !== \"number\") {\n            return null;\n        }\n\n        return token;\n    }\n\n    for (var i = 0; i < str.length; i++) {\n        var char = str[i];\n\n        if (char != false || char === \"0\") {\n            if (token.offset === -1) {\n                token.offset = i;\n            }\n\n            var _char = char.toLowerCase();\n            var pos = NUM_SEQUENCE.indexOf(_char);\n\n            if (pos === -1) {\n                break;\n            } else if (_char === \"e\") {\n                if (token.radix === 16 || (\n                    token.radix === 10 && matches.indexOf(char) === -1)\n                ) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (_char === \"b\" || _char === \"o\" || _char === \"x\") {\n                if ((matches.length === 1 && matches[0] === \"0\") || (\n                    matches.length === 2 && matches[1] === \"0\" && (\n                        matches[0] === \"-\" || matches[0] === \"+\"\n                    )\n                )) {\n                    token.radix = ({ b: 2, o: 8, x: 16 })[_char];\n                    matches += char;\n                } else if (_char === \"b\" && token.radix === 16) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (pos < 8) {\n                if (matches.length === 0 || (\n                    matches.length === 1 && (\n                        matches[0] === \"-\" || matches[0] === \"+\"\n                    )\n                )) {\n                    if (char === \"0\") {\n                        token.radix = 8;\n                    } else {\n                        token.radix = 10;\n                    }\n                }\n                matches += char;\n            } else if (pos < 10) {\n                if (token.radix === 2 || token.radix === 8) {\n                    token.radix = 10;\n                }\n                matches += char;\n            } else if (pos < 16) {\n                if (token.radix === 16) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (char === \".\") {\n                if (matches.length === 0) {\n                    token.radix = 10;\n                    matches += char;\n                } else if (token.radix === 10 && matches.indexOf(\".\") === -1) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else { // -+\n                var prevChar = str[i - 1];\n                if (matches.length === 0 || ( // signed number\n                    prevChar === \"e\" || prevChar === \"E\" // scientific notation\n                )) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    token.source = matches;\n    token.length = matches.length;\n    token.offset = token.offset === -1 ? 0 : token.offset;\n\n    if (matches) {\n        if (token.radix === 8 && /[oO]/.test(matches) === false) {\n            token.value = parseInt(matches, 8);\n        } else if (token.radix !== 10) {\n            if (matches[0] === \"-\") {\n                token.value = -Number(matches.slice(1));\n            } else if (matches[0] === \"+\") {\n                token.value = Number(matches.slice(1));\n            } else {\n                token.value = Number(matches);\n            }\n        } else {\n            token.value = Number(matches);\n        }\n    }\n\n    var boundaries = token.radix === 10 ? /^\\s*[,;:)\\]}\\/]|^\\s*$/ : undefined;\n\n    if (isNaN(token.value) || (\n        !allowTrailings && !strictMatch(str, token, boundaries)\n    )) {\n        return null;\n    }\n\n    return token;\n}\n\nexports.parse = parse;\n/**\n * @param {string} str \n * @param {boolean} strict \n */\nfunction parse(str, strict) {\n    var token = parseToken(str, !strict);\n    return token ? token.value : undefined;\n}\n\nfunction isRadix(str, radix) {\n    var token = parseToken(str);\n    return token ? token.radix == radix : false;\n}\n\n/**\n * @param {string} str \n */\nexports.isBin = function isBin(str) {\n    return isRadix(str, 2);\n};\n\n/**\n * @param {string} str \n */\nexports.isOct = function isOct(str) {\n    return isRadix(str, 8);\n};\n\n/**\n * @param {string} str \n */\nexports.isDec = function isDec(str) {\n    return isRadix(str, 10);\n};\n\n/**\n * @param {string} str \n */\nexports.isHex = function isHex(str) {\n    return isRadix(str, 16);\n};\n\n/**\n * @param {string} str \n */\nexports.isNaN = function isNaN(str) {\n    var value = parse(str, true);\n    return value === undefined || Number.isNaN(value);\n};\n\n/**\n * @param {string} str \n */\nexports.isFinite = function isFinite(str) {\n    return Number.isFinite(parse(str, true));\n};\n\n/**\n * @param {number} num\n * @param {2 | 8 | 10 | 16} radix\n */\nexports.toLiteral = function toLiteral(num, radix) {\n    if (Number.isNaN(num) || num === Infinity) {\n        return keyword.toLiteral(num);\n    } else {\n        radix = radix || 10;\n        return ({ 2: \"0b\", 8: \"0o\", 10: \"\", 16: \"0x\" })[radix] + num.toString(radix);\n    }\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\n\nvar FLAGS = \"gimsuy\";\n\nexports.parseToken = parseToken;\n/**\n * \n * @param {string} str \n * @returns {{ source: string, offset: number, length: number, value: RegExp }}\n */\nfunction parseToken(str) {\n    var token = { value: null, offset: -1, length: 0 };\n    var source = \"\";\n    var flags = \"\";\n    var closed = false;\n\n    for (var i = 0; i < str.length; i++) {\n        var char = str[i];\n\n        if (char != false || source) {\n            if (token.offset === -1) {\n                token.offset = i;\n            }\n\n            if (char === \"/\") {\n                if (source.length === 0 || str[i - 1] === \"\\\\\") {\n                    source += char;\n                } else if (closed) {\n                    return null;\n                } else {\n                    source += char;\n                    closed = true;\n                }\n            } else if (source[0] !== \"/\") {\n                return null;\n            } else if (closed && FLAGS.indexOf(char) >= 0 && !~flags.indexOf(char)) {\n                flags += char;\n            } else if (!closed) {\n                source += char;\n            } else {\n                break;\n            }\n        }\n    }\n\n    token.source = source + flags;\n    token.offset = token.offset === -1 ? 0 : token.offset;\n    token.length = source.length + flags.length;\n\n    try {\n        token.value = new RegExp(source.slice(1, -1), flags);\n    } catch (e) {\n        return null;\n    }\n\n    if (!strictMatch(str, token)) {\n        return null;\n    }\n\n    return token;\n}\n\n/**\n * @param {string} str\n */\nexports.parse = function parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n};\n\n/**\n * @param {RegExp} re\n */\nexports.toLiteral = function toLiteral(re) {\n    return String(re);\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar INLINE_COMMENT = /^\\s*\\/\\/.*\\n*?/;\nvar MULTI_LINE_COMMENT = /^\\s*\\/\\*[\\s\\S]*?\\*\\//;\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: string, type: \"//\" | \"/*\" | \"/**\" }} \n */\nfunction parseToken(str) {\n    var token = { source: \"\", offset: 0, length: 0, value: \"\", type: \"\" };\n    var match = INLINE_COMMENT.exec(str) || MULTI_LINE_COMMENT.exec(str);\n\n    if (match) {\n        token.offset = match[0].indexOf(\"/\");\n        token.length = match[0].length - token.offset;\n        token.source = token.value = match[0].slice(token.offset);\n\n        if (token.value[1] === \"/\") {\n            token.type = \"//\";\n        } else if (token.value.slice(1, 3) === \"**\") {\n            token.type = \"/**\"\n        } else {\n            token.type = \"/*\";\n        }\n\n        return token;\n    } else {\n        return null;\n    }\n}\n\n/**\n * \n * @param {string} str \n * @param {boolean} strip Strip meaningless characters.\n */\nexports.parse = function parse(str, strip) {\n    var token = parseToken(str);\n\n    if (!token) return;\n\n    if (!strip) {\n        return token.value;\n    } else if (token.type === \"//\") {\n        return token.value.replace(/^\\/\\/\\s*/, \"\");\n    } else {\n        var lines = token.value.replace(/\\s*\\*\\/$/, \"\").split(\"\\n\");\n        var value = lines[0].replace(/^\\/\\*\\s*/, \"\");\n        var isNewLine = false;\n\n        for (var i = 1; i < lines.length; i++) {\n            if (/^[\\s\\*]*$/.test(lines[i])) {\n                if (!isNewLine) {\n                    value += \"\\n\";\n                    isNewLine = true;\n                }\n            } else {\n                value += (isNewLine ? \"\" : \" \") + lines[i].replace(/^[\\s\\*]*/, \"\");\n                isNewLine = false;\n            }\n        }\n\n        return value;\n    }\n};\n\n/**\n * @param {string} str\n * @param {\"//\" | \"/*\" | \"/**\"} type\n * @param {string} indent Indent all rest lines of the comment with the given spaces.\n */\nexports.toLiteral = function toLiteral(str, type, indent) {\n    type = type || \"//\";\n    indent = indent || \"\";\n\n    var hasMultiLine = str.indexOf(\"\\n\") >= 0;\n\n    if (!hasMultiLine) {\n        if (type === \"//\") {\n            return \"// \" + str;\n        } else {\n            return type + \" \" + str + \" */\";\n        }\n    } else {\n        var lines = str.split(\"\\n\");\n\n        if (type === \"//\") {\n            lines[0] = \"// \" + lines[0];\n        } else {\n            lines.unshift(type);\n        }\n\n        for (var i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].replace(/^\\s*/, \"\");\n\n            if (type == \"//\") {\n                lines[i] = indent + \"// \" + lines[i];\n            } else {\n                lines[i] = indent + \" * \" + lines[i];\n            }\n        }\n\n        if (type !== \"//\") {\n            lines.push(indent + \" */\");\n        }\n\n        return lines.join(\"\\n\");\n    }\n};","module.exports = require(\"assert\");","import get = require(\"get-value\");\nimport set = require(\"set-value\");\nimport { pick } from \"./util\";\nimport { Variable, CompoundTypes, getInstance, IsNode } from \"./types\";\nimport {\n    LiteralToken,\n    string,\n    number,\n    regexp,\n    comment,\n    keyword\n} from 'literal-toolkit';\n\n/** A pattern to match Latin properties or type notations. */\nexport const TypeOrPorp = /^([a-z_][a-z0-9_]*)\\s*[:\\(]/i;\n\n/**\n * The interface that carries token details in the FRON string (source), e.g.\n * `filename`, `position`, `type` etc.\n */\nexport interface SourceToken {\n    /**\n     * The filename that parsed to the parser, if no filename is parsed, the \n     * default value will be `<anonymous>`.\n     */\n    filename: string;\n    /**\n     * The appearing position of the current token, includes both start and end \n     * positions.\n     */\n    position: {\n        start: {\n            line: number,\n            column: number\n        };\n        end: {\n            line: number,\n            column: number\n        };\n    };\n    /**\n     * The type of the current token, literal types are lower-cased and compound\n     * types are upper-cased.\n     */\n    type: string;\n    /**\n     * The parsed data of the current token, it may not be the final data since\n     * there may be a handler to deal with the current type.\n     */\n    data: any;\n    /** The token of the parent node. */\n    parent?: SourceToken;\n    /**\n     * The path of the current token, only for object properties and array \n     * elements.\n     */\n    path?: string;\n    /**\n     * All the comments in the current token. When parsing a comment token, it \n     * will be appended to the closest parent node, unless the comment is the \n     * very first token. Comments are not important to the parser and will be \n     * skipped when composing data.\n     */\n    comments?: SourceToken[];\n}\n\n/**\n * SourceToken is a class constructor as well, it is used to distinguish \n * the token object from all objects.\n */\nexport class SourceToken implements SourceToken {\n    constructor(token: SourceToken) {\n        Object.assign(this, token);\n    }\n}\n\n/** Carries details of the current position of the parsing cursor. */\nexport interface CursorToken {\n    index: number;\n    line: number;\n    column: number;\n    filename: string;\n}\n\n/**\n * Throws syntax error when the current token is invalid and terminate the \n * parser immediately.\n */\nexport function throwSyntaxError(token: SourceToken, char: string) {\n    let filename = token.filename,\n        type = token.type ? token.type + \" token\" : \"token \" + char,\n        { line, column } = token.position.start;\n    throw new SyntaxError(`Unexpected ${type} in ${filename}:${line}:${column}`);\n}\n\n/**\n * Gets the customized handler of the given type for parsing, may return \n * undefined if no handler is registered.\n */\nexport function getHandler(type: string): (data: any) => any {\n    return get(CompoundTypes[type], \"prototype.fromFRON\");\n}\n\n/**\n * Normalizes the given path, resolving '..' and '.' segments, and change path\n * separators to platform preference.\n */\nfunction normalizePath(path: string): string {\n    let parts = path.split(/\\/|\\\\/),\n        sep = IsNode ? \"/\" : (process.platform == \"win32\" ? \"\\\\\" : \"/\");\n\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        } else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n\n    return parts.join(sep);\n}\n\n/** Gets the last elements of an array-like object. */\nfunction last<T>(target: ArrayLike<T>): T {\n    return target[target.length - 1];\n}\n\n/** Parses every token in the FRON string. */\nfunction doParseToken(\n    str: string,\n    parent: SourceToken,\n    cursor: CursorToken,\n    listener?: (token: SourceToken) => void\n): SourceToken {\n    let char: string;\n    let token: SourceToken;\n\n    loop:\n    while ((char = str[cursor.index])) {\n        if (<any>char == false && char !== \"0\") {\n            // For falsy characters (except string '0'), only move the cursor \n            // forward, and do not parse any tokens.\n\n            cursor.index++;\n\n            if (char === \"\\n\") {\n                // Meet new line, increase the line number and move the column \n                // to the line head.\n                cursor.line++;\n                cursor.column = 1;\n            } else {\n                // Otherwise increase the column number only.\n                cursor.column++;\n            }\n\n            continue;\n        }\n\n        let remains: string,\n            dataToken: LiteralToken & { value: any, type?: string };\n\n        // Use a SourceToken instance, so that it could be distinguished from\n        // common objects.\n        token = new SourceToken({\n            filename: cursor.filename,\n            position: {\n                start: pick(cursor, [\"line\", \"column\"]),\n                end: undefined\n            },\n            type: undefined,\n            data: undefined,\n        });\n\n        // Using this method, so that the parent property won't be always showed\n        // up on the token.\n        if (parent) token.parent = parent;\n\n        switch (char) {\n            case \",\":\n                // A comma (`,`) appears right after a property value in an \n                // object, or an element in an array.\n                if (parent && [\"Object\", \"Array\"].indexOf(parent.type) >= 0) {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \":\":\n                // A colon (`:`) appears right after a property name in an \n                // object.\n                if (parent && parent.type === \"property\") {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \"(\":\n                // The open bracket (`(`) appears right after a compound type \n                // name, which will be parsed as an individual token, and the \n                // bracket only indicates that it's the beginning of the type \n                // container. A compound type notation uses a type name and a \n                // pair of brackets to form a container, inside the container, \n                // is an pure object literal or array literal.\n                // The parent here is the very type name node of the compound \n                // type notation.\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \")\":\n                // The closing bracket (`)`) indicates the end position of a \n                // compound type container, see above.\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++\n                } else {\n                    throwSyntaxError(token, char);\n                }\n\n                // Break the loop means the current node has been fully parsed,\n                // if the node is not yet fully parsed, should just break the \n                // switch block and continue parsing. Once a token has been \n                // fully parsed, break the loop and go to the end of the \n                // function for summary, gather and fill the token details. \n                break loop;\n\n            case \"{\": // object\n            case \"[\": // array\n                // Like the very JavaScript style, an object literal uses a pair\n                // of curly braces to contain key-value pairs, and an array\n                // literal uses a pair of square brackets to contain elements.\n                let isArray = char === \"[\";\n\n                cursor.index++;\n                cursor.column++;\n                token.type = isArray ? \"Array\" : \"Object\";\n                token.data = isArray ? [] : {};\n\n                // Objects and arrays contains sub-nodes (inner tokens), so \n                // recursively calling `doParseToken` to parse them before \n                // parsing continuing tokens. Since the cursor is a reference,\n                // not a copy, when parsing inner tokens and move the cursor, \n                // the outside node will follow the cursor, and keep parsing\n                // from where the inner nodes ends.\n                doParseToken(str, token, cursor, listener);\n                break loop;\n\n            case \"}\": // closing sign of an object\n            case \"]\": // closing sign of an array\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n\n                // The closing bracket of an object or array indicates the \n                // \"block\" is finished, and should no longer try to parse \n                // remaining tokens since they don't belong to the object or the\n                // array. `doParseToken()` will try to parse remaining tokens\n                // once a former token is parsed, since we don't need to parse \n                // them, return immediately to prevent that happens. \n                return;\n\n            case \"'\": // single-quoted string\n            case '\"': // double-quoted string\n            case \"`\": // back-quoted string\n                // Once a token type has been identified, assign it to the token\n                // object immediately, so that when even the token is invalid \n                // and throw a syntax error, the error can still tell what kind \n                // of token that is.\n                token.type = \"string\";\n\n                if ((dataToken = string.parseToken(str.slice(cursor.index)))) {\n                    let lines = dataToken.source.split(\"\\n\");\n\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.line += lines.length - 1;\n\n                    if (lines.length > 1) {\n                        // If the string takes multiple lines, move the column \n                        // number to the end of the last line.\n                        cursor.column = last(lines).length + 1;\n                    } else {\n                        cursor.column += dataToken.length;\n                    }\n                } else {\n                    console.log(str.slice(cursor.index));\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n\n            case \"/\": // regular expression or comment\n                token.type = \"regexp\";\n                remains = str.slice(cursor.index);\n\n                if ((dataToken = regexp.parseToken(remains))) { // regexp\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if ((dataToken = comment.parseToken(remains))) { // comment\n                    token.type = \"comment\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n\n                    if (dataToken.type !== \"//\") {\n                        // Multi-line comment starts with `/*` or `/**`.\n                        let lines = dataToken.source.split(\"\\n\");\n                        cursor.line += lines.length - 1;\n\n                        if (lines.length > 1) {\n                            cursor.column = last(lines).length + 1;\n                        } else {\n                            cursor.column += dataToken.length;\n                        }\n                    }\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n\n            default:\n                remains = str.slice(cursor.index);\n                let matches: RegExpMatchArray;\n\n                if ((dataToken = number.parseToken(remains))) { // number\n                    token.type = \"number\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if ((dataToken = keyword.parseToken(remains))) { // keyword\n                    token.type = \"keyword\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if (matches = remains.match(TypeOrPorp)) {\n                    let lines = matches[0].split(\"\\n\"),\n                        key = matches[1];\n\n                    cursor.index += key.length;\n                    cursor.line += lines.length - 1;\n\n                    if (lines.length > 1) {\n                        // If there are new lines between the property (or type \n                        // name) and the colon(or open bracket), move the column\n                        // number to the head of the line.\n                        cursor.column = 1;\n                    } else {\n                        cursor.column += key.length;\n                    }\n\n                    if (last(matches[0]) === \":\") { // property\n                        token.type = \"property\";\n\n                        // A property can only appears inside an object.\n                        if (parent && parent.type === \"Object\") {\n                            token.data = key;\n                        } else {\n                            throwSyntaxError(token, char);\n                        }\n                    } else { // compound type\n                        token.type = key;\n\n                        if (!parent && token.type === \"Reference\") {\n                            // A reference type con only appears inside a \n                            // compound type (object, array or something else).\n                            throwSyntaxError(token, char);\n                        } else {\n                            token.data = doParseToken(\n                                str,\n                                token,\n                                cursor,\n                                listener\n                            );\n\n                            // Since the token of a customized compound type \n                            // contains an extra closing bracket \")\", and \n                            // potential spaces, using doParseToken() can let \n                            // the cursor travel through them.\n                            doParseToken(str, token, cursor);\n                        }\n                    }\n                } else {\n                    isFinite(Number(char)) && (token.type = \"number\");\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n        }\n    }\n\n    token.position.end = pick(cursor, [\"line\", \"column\"]);\n\n    if (token.parent && token.type === \"comment\") {\n        token.parent.comments = token.parent.comments || [];\n        token.parent.comments.push(token);\n    } else if (token.parent && token.parent.type === \"Object\") { // object\n        let prop = token.data,\n            isVar = Variable.test(prop),\n            prefix = get(token, \"parent.parent.path\", \"\"),\n            path = isVar ? (prefix ? \".\" : \"\") + `${prop}` : `['${prop}']`;\n\n        // If the parent node is an object, that means the current node is a \n        // property node, should set the path and parse the property value as a\n        // child node.\n        token.path = (prefix || \"\") + path;\n        token.type = \"property\";\n\n        // Use a while block to parse the property value token, in case there \n        // are comments before the value node.\n        while (token.data = doParseToken(str, token, cursor, listener)) {\n            if (!token.data || token.data.type !== \"comment\") break;\n        }\n\n        // Append the current node to the parent node as a new property. \n        token.parent.data[prop] = token;\n    } else if (token.parent && token.parent.type === \"Array\") { // array\n        let prefix = get(token, \"parent.path\", \"\");\n\n        // If the parent node is an array, append the current node to the parent\n        // node as its element.\n        token.path = `${prefix}[${token.parent.data.length}]`;\n        token.parent.data.push(token);\n    }\n\n    // If there is a listener bound, call it to watch all parsing moments.\n    listener && listener.call(void 0, token);\n\n    if (token.parent && [\"Object\", \"Array\"].indexOf(token.parent.type) >= 0) {\n        // If the parent node is either object or array, try to parse remaining \n        // tokens as its properties (or elements).\n        return doParseToken(str, token.parent, cursor, listener);\n    } else {\n        return token;\n    }\n}\n\n/**\n * Composes all tokens (include children nodes) to a JavaScript object and \n * gather all references into a map.\n */\nfunction compose(token: SourceToken, refMap: { [path: string]: string }): any {\n    let data: any;\n\n    switch (token.type) {\n        case \"Object\":\n            data = {};\n            for (let prop in token.data) {\n                // Every property in an object token is also SourceToken, which\n                // should be composed recursively.\n                data[prop] = compose(token.data[prop].data, refMap);\n            }\n            break;\n\n        case \"Array\":\n            data = [];\n            for (let item of token.data) {\n                // Every element in an array token is also SourceToken, which\n                // should be composed recursively.\n                data.push(compose(item, refMap));\n            }\n            break;\n\n        case \"Reference\":\n            // The data contained by Reference is a SourceToken with string,\n            // which should be composed first before using it.\n            refMap[token.parent.path] = compose(token.data, refMap);\n            break;\n\n        default:\n            if (token.data instanceof SourceToken) {\n                let handle = getHandler(token.type),\n                    inst = getInstance(token.type);\n\n                data = compose(token.data, refMap); // try to compose first\n\n                // Try to call registered parsing handler to get expected data.\n                data = handle\n                    ? handle.call(inst || data, data)\n                    : data;\n            } else if (token.type !== \"comment\") {\n                data = token.data;\n            }\n            break;\n    }\n\n    return data;\n}\n\n/** Composes a token or token tree to a JavaScript object. */\nexport function composeToken(token: SourceToken): any {\n    let refMap = {},\n        data = compose(token, refMap);\n\n    // Sets all references according to the map.\n    for (let path in refMap) {\n        let target = refMap[path];\n        let ref = target ? get(data, target) : data;\n        set(data, path, ref);\n    }\n\n    return data;\n}\n\n/**\n * Parses the given FRON string into a well-constructed token or token tree.\n * @param filename When parsing data from a file, given that filename to the \n *  parser, so that if the parser throws syntax error, it could address the \n *  position properly. The default value is `<anonymous>`.\n * @param listener If set, it will be called when parsing every token in the \n *  FRON string, and be helpful for programmatic usage.\n */\nexport function parseToken(\n    str: string,\n    filename?: string,\n    listener?: (token: SourceToken) => void\n): SourceToken {\n    return str ? doParseToken(str, null, {\n        index: 0,\n        line: 1,\n        column: 1,\n        filename: filename ? normalizePath(filename) : \"<anonymous>\"\n    }, listener) : null;\n}\n\n/**\n * Parses the given FRON string to JavaScript object.\n * @param filename When parsing data from a file, given that filename to the \n *  parser, so that if the parser throws syntax error, it could address the \n *  position properly. The default value is `<anonymous>`.\n */\nexport function parse(str: string, filename?: string): any {\n    return str ? composeToken(parseToken(str, filename)) : void 0;\n}","/*!\n * set-value <https://github.com/jonschlinkert/set-value>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isPlain = require('is-plain-object');\n\nfunction set(target, path, value, options) {\n  if (!isObject(target)) {\n    return target;\n  }\n\n  let opts = options || {};\n  const isArray = Array.isArray(path);\n  if (!isArray && typeof path !== 'string') {\n    return target;\n  }\n\n  let merge = opts.merge;\n  if (merge && typeof merge !== 'function') {\n    merge = Object.assign;\n  }\n\n  const keys = isArray ? path : split(path, opts);\n  const len = keys.length;\n  const orig = target;\n\n  if (!options && keys.length === 1) {\n    result(target, keys[0], value, merge);\n    return target;\n  }\n\n  for (let i = 0; i < len; i++) {\n    let prop = keys[i];\n\n    if (!isObject(target[prop])) {\n      target[prop] = {};\n    }\n\n    if (i === len - 1) {\n      result(target, prop, value, merge);\n      break;\n    }\n\n    target = target[prop];\n  }\n\n  return orig;\n}\n\nfunction result(target, path, value, merge) {\n  if (merge && isPlain(target[path]) && isPlain(value)) {\n    target[path] = merge({}, target[path], value);\n  } else {\n    target[path] = value;\n  }\n}\n\nfunction split(path, options) {\n  const id = createKey(path, options);\n  if (set.memo[id]) return set.memo[id];\n\n  const char = (options && options.separator) ? options.separator : '.';\n  let keys = [];\n  let res = [];\n\n  if (options && typeof options.split === 'function') {\n    keys = options.split(path);\n  } else {\n    keys = path.split(char);\n  }\n\n  for (let i = 0; i < keys.length; i++) {\n    let prop = keys[i];\n    while (prop && prop.slice(-1) === '\\\\' && keys[i + 1]) {\n      prop = prop.slice(0, -1) + char + keys[++i];\n    }\n    res.push(prop);\n  }\n  set.memo[id] = res;\n  return res;\n}\n\nfunction createKey(pattern, options) {\n  let id = pattern;\n  if (typeof options === 'undefined') {\n    return id + '';\n  }\n  const keys = Object.keys(options);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    id += ';' + key + '=' + String(options[key]);\n  }\n  return id;\n}\n\nfunction isObject(val) {\n  switch (typeof val) {\n    case 'null':\n      return false;\n    case 'object':\n      return true;\n    case 'function':\n      return true;\n    default: {\n      return false;\n    }\n  }\n}\n\nset.memo = {};\nmodule.exports = set;\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n"],"sourceRoot":""}