{"version":3,"sources":["webpack://FRON/webpack/universalModuleDefinition","webpack://FRON/webpack/bootstrap","webpack://FRON/./node_modules/get-value/index.js","webpack://FRON/./node_modules/literal-toolkit/lib/util.js","webpack://FRON/./src/types.ts","webpack://FRON/./node_modules/isobject/index.js","webpack://FRON/./node_modules/literal-toolkit/index.js","webpack://FRON/./node_modules/safe-string-literal/index.js","webpack://FRON/./node_modules/literal-toolkit/lib/keyword.js","webpack://FRON/./src/util.ts","webpack://FRON/./src/index.ts","webpack://FRON/./src/stringify.ts","webpack://FRON/./node_modules/literal-toolkit/lib/string.js","webpack://FRON/./node_modules/literal-toolkit/lib/number.js","webpack://FRON/./node_modules/literal-toolkit/lib/regexp.js","webpack://FRON/./node_modules/literal-toolkit/lib/comment.js","webpack://FRON/external \"assert\"","webpack://FRON/./src/parse.ts","webpack://FRON/./node_modules/set-value/index.js","webpack://FRON/./node_modules/is-plain-object/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isObject","join","segs","joinChar","options","isValid","target","isValidObject","val","Array","isArray","path","default","String","isString","splitChar","separator","split","len","length","idx","prop","slice","hasProp","BOUNDARIES","strictMatch","str","token","boundaries","arguments","leftOver","offset","test","util_1","IsNode","global","Variable","CompoundTypes","getType","data","undefined","ctor","type","getInstance","FRONEntryBase","[object Object]","assign","FRONString","checkProto","proto","fromFRON","TypeError","checkType","ReferenceError","copyProto","source","pick","register","Error","constructor","keyFor","for","Number","Boolean","forEach","valueOf","RegExp","toString","flags","Date","toISOString","Map","Set","values","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","from","EvalError","RangeError","SyntaxError","reserved","omit","defineProperties","writable","configurable","message","stack","AssertionError","Buffer","string","number","keyword","regexp","comment","escape","excludes","replace","char","indexOf","unescape","chars","KEYWORDS","parseToken","match","exec","parse","toLiteral","keys","obj","props","push","Reflect","ownKeys","getPrototypeOf","arr","iterator","item","result","stringify_1","stringify","parse_1","composeToken","SourceToken","types_1","literal_toolkit_1","stringifyCommon","indent","originalIndent","refMap","getHandler","has","set","handlers","container","toFRON","x","isVar","res","handler","apply","pretty","SINGLE_QUOTE","DOUBLE_QUOTE","BACK_QUOTE","quote","matches","skippedLength","removeUnusedEscapes","exclues","NUM_SEQUENCE","allowTrailings","NaN","radix","_token","_char","toLowerCase","pos","b","prevChar","parseInt","isNaN","strict","isRadix","BIN","OCT","DEC","HEX","isBin","isOct","isDec","isHex","isFinite","num","Infinity","2","8","10","16","FLAGS","closed","e","re","INLINE_COMMENT","MULTI_LINE_COMMENT","strip","lines","isNewLine","unshift","require","TypeOrPorp","throwSyntaxError","filename","line","column","position","start","normalizePath","parts","sep","process","platform","splice","last","compose","parent","handle","inst","ref","listener","doParseToken","cursor","loop","index","remains","dataToken","end","console","log","comments","prefix","isPlain","opts","merge","id","pattern","createKey","memo","orig","isObjectObject","prot"],"mappings":"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","file":"fron.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FRON\"] = factory();\n\telse\n\t\troot[\"FRON\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","/*!\n * get-value <https://github.com/jonschlinkert/get-value>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isObject = require('isobject');\n\nmodule.exports = function(target, path, options) {\n  if (!isObject(options)) {\n    options = { default: options };\n  }\n\n  if (!isValidObject(target)) {\n    return typeof options.default !== 'undefined' ? options.default : target;\n  }\n\n  if (typeof path === 'number') {\n    path = String(path);\n  }\n\n  const isArray = Array.isArray(path);\n  const isString = typeof path === 'string';\n  const splitChar = options.separator || '.';\n  const joinChar = options.joinChar || (typeof splitChar === 'string' ? splitChar : '.');\n\n  if (!isString && !isArray) {\n    return target;\n  }\n\n  if (isString && path in target) {\n    return isValid(path, target, options) ? target[path] : options.default;\n  }\n\n  let segs = isArray ? path : split(path, splitChar, options);\n  let len = segs.length;\n  let idx = 0;\n\n  do {\n    let prop = segs[idx];\n    if (typeof prop === 'number') {\n      prop = String(prop);\n    }\n\n    while (prop && prop.slice(-1) === '\\\\') {\n      prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options);\n    }\n\n    if (prop in target) {\n      if (!isValid(prop, target, options)) {\n        return options.default;\n      }\n\n      target = target[prop];\n    } else {\n      let hasProp = false;\n      let n = idx + 1;\n\n      while (n < len) {\n        prop = join([prop, segs[n++]], joinChar, options);\n\n        if ((hasProp = prop in target)) {\n          if (!isValid(prop, target, options)) {\n            return options.default;\n          }\n\n          target = target[prop];\n          idx = n - 1;\n          break;\n        }\n      }\n\n      if (!hasProp) {\n        return options.default;\n      }\n    }\n  } while (++idx < len && isValidObject(target));\n\n  if (idx === len) {\n    return target;\n  }\n\n  return options.default;\n};\n\nfunction join(segs, joinChar, options) {\n  if (typeof options.join === 'function') {\n    return options.join(segs);\n  }\n  return segs[0] + joinChar + segs[1];\n}\n\nfunction split(path, splitChar, options) {\n  if (typeof options.split === 'function') {\n    return options.split(path);\n  }\n  return path.split(splitChar);\n}\n\nfunction isValid(key, target, options) {\n  if (typeof options.isValid === 'function') {\n    return options.isValid(key, target);\n  }\n  return true;\n}\n\nfunction isValidObject(val) {\n  return isObject(val) || Array.isArray(val) || typeof val === 'function';\n}\n","var BOUNDARIES = /^\\s*[,;)\\]}\\/]|^\\s*$/;\r\n\r\nexports.strictMatch = strictMatch;\r\n/**\r\n * @param {string} str \r\n * @param {{ offset: number, length: number }} token \r\n */\r\nfunction strictMatch(str, token) {\r\n    var boundaries = arguments[2] || BOUNDARIES;\r\n    var leftOver = str.slice(token.offset + token.length);\r\n    return !leftOver || boundaries.test(leftOver);\r\n}","import get = require(\"get-value\");\nimport { pick, omit, values } from \"./util\";\n\n/**\n * The interface restricts if a user defined type can be registered as FRON type.\n */\nexport interface FRONEntry {\n    toFRON?(): any;\n    fromFRON(data: any): any;\n};\n\n/** Indicates a class constructor that implements the FRONEntry interface. */\nexport type FRONConstructor = new (...args: any[]) => FRONEntry;\n\n/** Whether the current environment is NodeJS. */\nexport const IsNode = typeof global === \"object\"\n    && get(global, \"process.release.name\") === \"node\";\n\n/** The pattern that matches valid JavaScript Latin variable names. */\nexport const Variable = /^[a-z_][a-z0-9_]*$/i;\n\n/** \n * Stores all supported compound types, includes the types that user registered.\n */\nexport const CompoundTypes: { [type: string]: FRONConstructor } = {\n    // objects and arrays are handled internally by the stringifier and parser,\n    // register here is for checkers to identify them as compound types.\n    Object: <any>Object,\n    Array: <any>Object\n};\n\n/**\n * Gets the type name in string of the input data, may return a literal type \n * or a compound type.\n */\nexport function getType(data: any): string {\n    if (data === undefined) {\n        return;\n    } else if (data === null) {\n        return \"null\";\n    } else {\n        let type = typeof data,\n            ctor: FRONConstructor;\n\n        if (type !== \"object\") {\n            return type === \"symbol\" ? \"Symbol\" : type;\n        } else if (ctor = get(data, \"constructor\")) {\n            for (let type in CompoundTypes) {\n                if (ctor === CompoundTypes[type])\n                    return type;\n            }\n\n            return ctor.name;\n        }\n    }\n}\n\n/**\n * Gets an instance of the given type, may return undefined if the type isn't \n * registered, this function calls `Object.create()` to create instance, so the\n * constructor will not be called automatically.\n * \n * NOTE: This function may return `undefined` if the given type isn't registered.\n */\nexport function getInstance<T = any>(\n    type: string | (new (...args: any[]) => T)\n): T {\n    type = typeof type === \"function\" ? type.name : type;\n    return CompoundTypes[type] && Object.create(CompoundTypes[type].prototype);\n}\n\n/**\n * When register a type with an object as its prototype, a new sub-class will \n * be created to extend FRONEntryBase and merge the object to its prototype. In \n * the parsing phase, a FRONEntryBase instance will be created via \n * `Object.create()` and apply the `fromFRON()` method to it.\n */\nexport class FRONEntryBase implements FRONEntry {\n    toFRON() {\n        return Object.assign({}, this);\n    }\n\n    fromFRON(data: any) {\n        return data;\n    }\n}\n\n/**\n * A special type used to mark up user defined FRON notations, if a `toFRON()`\n * method return a `FRONString`, them it will not be stringified again with\n * common approach, just use the represented value as the output notation.\n * NOTE: the personalized notation must use valid syntax that can be identified \n * by the parser, it is either a literal, or a compound type.\n */\nexport class FRONString extends String { }\n\n/** Checks if the given prototype can be registered as an FRON type. */\nfunction checkProto(name: string, proto: FRONEntry) {\n    if (typeof proto.fromFRON !== \"function\") {\n        // Every constructor that used as FRON type should include a \n        // `fromFRON()` method, so that when parsing the FRON string, the parser\n        // could call the method to produce an expected instance of the type.\n        throw new TypeError(`prototype method ${name}.fromFRON() is missing`);\n    } else if (proto.fromFRON.length < 1) {\n        // The `fromFRON()` method needs to accept at least one argument, which \n        // is the data parsed from the FRON string, usually used to create a new\n        // instance of the type.\n        // The second argument `type` is optional, when pass, it is the type \n        // notation in string of the token.\n        throw new TypeError(`prototype method ${name}.fromFRON() is invalid`);\n    }\n}\n\n/** Checks if a type is registered. */\nfunction checkType(type: string | FRONConstructor) {\n    type = typeof type === \"string\" ? type : type.name;\n    if (!CompoundTypes[type]) {\n        throw new ReferenceError(`Unrecognized type: ${type}`);\n    }\n}\n\n/**\n * Copies the FRONEntry protocol methods from a FRONConstructor to another \n * constructor.\n */\nfunction copyProto(source: object | FRONConstructor, target: Function) {\n    source = typeof source === \"function\" ? source.prototype : source;\n    Object.assign(target.prototype, pick(source, [\n        \"toFRON\",\n        \"fromFRON\"\n    ]));\n}\n\n/**\n * Registers a customized data type so that the stringifier and parser can \n * identify it.\n * @example\n *  // Register a constructor with `toFRON` and `fromFRON` methods.\n *  register(User);\n * \n *  // Register a constructor and merger a customized prototype.\n *  register(Date, { toFRON() { ... }, fromFRON() { ... } });\n * \n *  // Register a non-constructor type with a customized prototype.\n *  register(\"Article\", { toFRON() { ... }, fromFRON() { ... } });\n * \n *  // Four ways to register an alias type.\n *  // NOTE: the former two will use the constructor `Student`\n *  // to create instance when parsing, but the last two will\n *  // use `User` since \"Student\" is not a constructor. However,\n *  // they all use the name \"Student\" as notation.\n *  register(Student, User);\n *  register(Student, \"User\");\n *  register(\"Student\", User);\n *  register(\"Student\", \"User\");\n */\nexport function register(\n    type: string | FRONConstructor | (new (...args: any[]) => any),\n    proto?: string | FRONConstructor | FRONEntry\n): void {\n    if (typeof type === \"function\") {\n        if (!proto) {\n            checkProto(type.name, type.prototype);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"string\") {\n            checkType(proto);\n            copyProto(CompoundTypes[proto], type);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"function\") {\n            checkProto(proto.name, proto.prototype);\n            copyProto(proto, type);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"object\") {\n            checkProto(type.name, proto);\n            copyProto(proto, type);\n            CompoundTypes[type.name] = type;\n        } else {\n            throw new Error(`Invalid prototype: ${proto}`);\n        }\n    } else if (typeof type === \"string\") {\n        if (typeof proto === \"string\") {\n            checkType(proto);\n            CompoundTypes[type] = CompoundTypes[proto];\n        } else if (typeof proto === \"function\") {\n            checkProto(proto.name, proto.prototype);\n            CompoundTypes[type] = proto;\n        } else if (typeof proto === \"object\") {\n            checkProto(type, proto);\n            let ctor: Function = proto.constructor;\n\n            if (ctor === Object)\n                ctor = class extends FRONEntryBase { };\n\n            copyProto(proto, ctor);\n            CompoundTypes[type] = <any>ctor;\n        } else {\n            throw new Error(`Invalid prototype: ${proto}`);\n        }\n    } else {\n        throw new TypeError(`Invalid type: ${type}`);\n    }\n}\n\n// Register handler for Symbol.\nregister(<any>Symbol, {\n    toFRON(this: symbol) {\n        return Symbol.keyFor(this);\n    },\n    fromFRON(data: string) {\n        return Symbol.for(data);\n    }\n});\n\n// Register handlers for Number, Boolean, String.\n[Number, Boolean, String].forEach(type => {\n    register(type, {\n        toFRON(this: String | Number | Boolean) {\n            return this.valueOf();\n        },\n        fromFRON(data: any) {\n            return new (<any>this.constructor)(data);\n        }\n    });\n});\n\n// Register handler for RegExp.\nregister(RegExp, {\n    toFRON(this: RegExp) {\n        return new FRONString(this.toString());\n    },\n    fromFRON(data: { source: string, flags: string }) {\n        // For FRON string to support object wrapped by RegExp, and literal is \n        // internally support by the parser.\n        return new (<any>this.constructor)(data.source, data.flags);\n    }\n});\n\n// Register handler for Date.\nregister(Date, {\n    toFRON(this: Date) {\n        return this.toISOString();\n    },\n    fromFRON(data: string) {\n        return new (<any>this.constructor)(data);\n    }\n});\n\n// Register handlers for Map and Set.\n[Map, Set].forEach(type => {\n    register(type, {\n        toFRON(this: Iterable<any>) {\n            return values(this);\n        },\n        fromFRON(data: any[]) {\n            return new (<any>this.constructor)(data);\n        }\n    });\n});\n\n// Register handlers for typed arrays.\n[\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array\n].forEach(type => {\n    register(type, {\n        toFRON(this: Iterable<number>) {\n            return values(this);\n        },\n        fromFRON(data: number[]) {\n            return (<any>this.constructor).from(data);\n        }\n    });\n});\n\n// Register handlers for all errors.\n[\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError\n].forEach(type => {\n    register(type, {\n        toFRON(this: Error) {\n            // When stringify an error, stringify all its member properties,\n            // include `name`, `message` and `stack`, since they may not be \n            // enumerated, so using `pick()` to fetch them manually.\n            let reserved = [\"name\", \"message\", \"stack\"];\n\n            return Object.assign({}, pick(this, reserved), omit(this, reserved));\n        },\n        fromFRON(this: Error, data: { [x: string]: any }) {\n            Object.defineProperties(this, {\n                name: {\n                    value: data.name,\n                    writable: true,\n                    configurable: true\n                },\n                message: {\n                    value: data.message,\n                    writable: true,\n                    configurable: true\n                },\n                stack: {\n                    value: data.stack,\n                    writable: true,\n                    configurable: true\n                }\n            });\n            Object.assign(this, omit(data, [\"name\", \"message\", \"stack\"]));\n\n            return this;\n        }\n    });\n});\n\nif (IsNode) {\n    // Register some well-known NodeJS types.\n    let AssertionError: FRONConstructor = require(\"assert\").AssertionError;\n    register(AssertionError, Error.name);\n    register(Buffer, Uint8Array.name);\n}","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nexports.string = require(\"./lib/string\");\r\nexports.number = require(\"./lib/number\");\r\nexports.keyword = require(\"./lib/keyword\");\r\nexports.regexp = require(\"./lib/regexp\");\r\nexports.comment = require(\"./lib/comment\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * @param {string} str \n * @param {string|string[]} excludes \n */\nfunction escape(str, excludes) {\n    return String(str).replace(/[\"'`\\\\\\b\\f\\n\\r\\t\\u2028\\u2029]/g, function (char) {\n        if (excludes && excludes.indexOf(char) >= 0)\n            return char;\n\n        switch (char) {\n            case '\"':\n            case \"'\":\n            case '`':\n            case \"\\\\\":\n                return \"\\\\\" + char;\n            case \"\\b\":\n                return \"\\\\b\";\n            case \"\\f\":\n                return \"\\\\f\";\n            case \"\\n\":\n                return \"\\\\n\";\n            case \"\\r\":\n                return \"\\\\r\";\n            case \"\\t\":\n                return \"\\\\t\";\n            case \"\\u2028\":\n                return \"\\\\u2028\";\n            case \"\\u2029\":\n                return \"\\\\u2029\";\n        }\n    });\n}\n\n/**\n * @param {string} str \n */\nfunction unescape(str) {\n    return String(str).replace(/\\\\[\"'`\\\\bfnrt]|\\\\u2028|\\\\u2029/g, function (chars) {\n        switch (chars) {\n            case '\\\\\"':\n            case \"\\\\'\":\n            case \"\\\\`\":\n            case \"\\\\\\\\\":\n                return chars[1];\n            case \"\\\\b\":\n                return \"\\b\";\n            case \"\\\\f\":\n                return \"\\f\";\n            case \"\\\\n\":\n                return \"\\n\";\n            case \"\\\\r\":\n                return \"\\r\";\n            case \"\\\\t\":\n                return \"\\t\";\n            case \"\\\\u2028\":\n                return \"\\u2028\";\n            case \"\\\\u2029\":\n                return \"\\u2029\";\n        }\n    });\n}\n\nexports.escape = escape;\nexports.unescape = unescape;","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nvar KEYWORDS = /^\\s*(true|false|null|NaN|Infinity)(\\s*[,;)\\]}]|\\s*$)/;\r\n\r\nexports.parseToken = parseToken;\r\n/**\r\n * @param {string} str\r\n * @returns {{ source: string, offset: number, length: number, value: true | false | null | NaN | Infinity }} \r\n */\r\nfunction parseToken(str) {\r\n    var match = KEYWORDS.exec(str);\r\n\r\n    if (match) {\r\n        var value;\r\n\r\n        switch (match[1]) {\r\n            case \"true\":\r\n                value = true;\r\n                break;\r\n            case \"false\":\r\n                value = false;\r\n                break;\r\n            case \"NaN\":\r\n            case \"Infinity\":\r\n                value = Number(match[1]);\r\n                break;\r\n            default:\r\n                value = null;\r\n                break;\r\n        }\r\n\r\n        return {\r\n            source: match[1],\r\n            offset: str.indexOf(match[1]),\r\n            length: match[1].length,\r\n            value: value\r\n        };\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * @param {string} str \r\n */\r\nexports.parse = function parse(str) {\r\n    var token = parseToken(str);\r\n    return token ? token.value : undefined;\r\n};\r\n\r\n/**\r\n * @param {true | false | null | NaN | Infinity} keyword\r\n */\r\nexports.toLiteral = function toLiteral(keyword) {\r\n    return String(keyword);\r\n};","/**\n * Gets all properties of an object, including those inherited from prototype.\n */\nexport function keys(obj: any) {\n    let props: (string | number | symbol)[] = [];\n\n    props.push(\n        ...Reflect.ownKeys(obj),\n        ...Reflect.ownKeys(Object.getPrototypeOf(obj)),\n    );\n\n    return Array.from(new Set(props));\n}\n\n/** Gets the values in the given iterable object. */\nexport function values<T>(data: Iterable<T> | { [x: string]: T }) {\n    let arr: T[] = [];\n\n    if (typeof data[Symbol.iterator] === \"function\") {\n        for (let item of (<Iterable<T>>data)) {\n            arr.push(item);\n        }\n    } else {\n        for (let key of keys(data)) {\n            arr.push(data[key]);\n        }\n    }\n\n    return arr;\n}\n\n/** Gets a copy of an object with only the specified keys. */\nexport function pick(obj: any, props: (string | number | symbol)[]): any {\n    let result = {};\n\n    for (let key of keys(obj)) {\n        if (props.indexOf(key) >= 0) {\n            result[key] = obj[key];\n        }\n    }\n\n    return result;\n}\n\n/** Gets a copy of an object without the specified keys. */\nexport function omit(obj: any, props: (string | number | symbol)[]): any {\n    let result = {};\n\n    for (let key of keys(obj)) {\n        if (props.indexOf(key) === -1 && typeof obj[key] !== \"function\") {\n            result[key] = obj[key];\n        }\n    }\n\n    return result;\n}","import { stringify } from \"./stringify\";\nimport { parse, parseToken, composeToken, SourceToken } from \"./parse\";\nimport {\n    register,\n    FRONEntry,\n    FRONEntryBase,\n    FRONConstructor,\n    FRONString,\n    getType,\n    getInstance\n} from \"./types\";\n\nexport {\n    register,\n    stringify,\n    parse,\n    parseToken,\n    composeToken,\n    SourceToken,\n    FRONEntry,\n    FRONEntryBase,\n    FRONConstructor,\n    FRONString,\n    getType,\n    getInstance\n};","import get = require(\"get-value\");\nimport { string } from \"literal-toolkit\";\nimport {\n    Variable,\n    CompoundTypes,\n    FRONString,\n    getType,\n} from './types';\n\n/** Stringifies any type of data in a common way. */\nfunction stringifyCommon(\n    data: any,\n    indent: string,\n    originalIndent: string,\n    path: string,\n    refMap: Map<any, string>\n): string {\n    let type = getType(data);\n\n    if (!type || type == \"function\") {\n        return;\n    } else if (type == \"null\") {\n        return type;\n    } else if (type == \"string\") {\n        return string.toLiteral(data);\n    } else if (type == \"Symbol\") {\n        return getHandler(type, indent, originalIndent, path, refMap)(data);\n    } else if (typeof data === \"object\") {\n        if (refMap.has(data)) {\n            // `Reference` is a special type in FRON, it indicates that the \n            // current property references to another property, they are \n            // `aliases` to each other. When stringifing, the first reached \n            // property will be transferred as usual, but other properties that \n            // reference to this property will only be notate as an `Reference` \n            // with the original path, and the parser can use that path to set\n            // property when parsing.\n            return \"Reference(\" + stringify(refMap.get(data)) + \")\";\n        } else {\n            refMap.set(data, path);\n            return getHandler(type, indent, originalIndent, path, refMap)(data);\n        }\n    } else {\n        return String(data);\n    }\n}\n\n/** Gets the handler to stringify the corresponding compound type. */\nfunction getHandler(\n    type: string,\n    indent: string,\n    originalIndent: string,\n    path: string,\n    refMap: Map<any, string>\n): (data: any) => string {\n    var handlers = {\n        \"Object\": (data: any) => {\n            let container: string[] = [];\n\n            if (typeof data.toFRON == \"function\") {\n                // If the given object includes a `toFRON()` method, call it and\n                // get the returning value as the data to be stringified.\n                data = data.toFRON();\n            }\n\n            if (data === undefined) return;\n\n            // Stringify all enumerable properties of the object.\n            for (let x in data) {\n                let isVar = Variable.test(x),\n                    prop = isVar ? x : `['${x}']`,\n                    res = stringifyCommon(\n                        data[x],\n                        indent + originalIndent,\n                        originalIndent,\n                        path + (isVar && path ? \".\" : \"\") + prop,\n                        refMap\n                    );\n\n                if (res === undefined)\n                    continue; // If the result returns undefined, skip it.\n                else if (indent)\n                    container.push((isVar ? x : stringify(x)) + `: ${res}`);\n                else\n                    container.push((isVar ? x : stringify(x)) + `:${res}`);\n            }\n\n            if (indent && container.length) { // use indentation\n                return \"{\\n\"\n                    + indent + container.join(\",\\n\" + indent) + \"\\n\"\n                    + indent.slice(0, -originalIndent.length) + \"}\";\n            } else {\n                return \"{\" + container.join(\",\") + \"}\";\n            }\n        },\n        \"Array\": (data: any[]) => {\n            let container: string[] = [];\n\n            // Only stringify iterable elements of the array.\n            for (let i = 0; i < data.length; i++) {\n                let res = stringifyCommon(\n                    data[i],\n                    indent + originalIndent,\n                    originalIndent,\n                    `${path}[${i}]`,\n                    refMap\n                );\n\n                // skip undefined result\n                (res !== undefined) && container.push(res);\n            }\n\n            if (indent && container.length) { // use indentation\n                return \"[\\n\"\n                    + indent + container.join(\",\\n\" + indent) + \"\\n\"\n                    + indent.slice(0, -originalIndent.length) + \"]\";\n            } else {\n                return \"[\" + container.join(\",\") + \"]\";\n            }\n        },\n    };\n\n    if (handlers[type]) {\n        return handlers[type];\n    } else {\n        return (data: any) => {\n            let handler: Function;\n\n            if (typeof data.toFRON == \"function\") {\n                // If the given object includes a `toFRON()` method, call it and\n                // get the returning value as the data to be stringified.\n                data = data.toFRON();\n            } else if (handler = get(CompoundTypes[type], \"prototype.toFRON\")) {\n                // If there is a customized handler registered to deal with the \n                // type, apply it to the data. The reason to call `apply()` \n                // instead of calling the method directly is that the handler \n                // method may not exist on the data instance, it may be \n                // registered with an object as prototype in the first place.\n                data = handler.apply(data);\n            } else {\n                // If no handler is found, stringify the data as an ordinary \n                // object with only its enumerable properties.\n                data = Object.assign({}, data);\n            }\n\n            if (data === undefined) {\n                return;\n            } else if (data instanceof FRONString) {\n                return data.valueOf();\n            } else {\n                return type + \"(\" + stringifyCommon(\n                    data,\n                    indent,\n                    originalIndent,\n                    path,\n                    refMap\n                ) + \")\";\n            }\n        }\n    }\n}\n\n/**\n * Stringifies the given data into a FRON string.\n * @param pretty The default indentation is two spaces, other than that, set \n *  any strings for indentation is allowed.\n */\nexport function stringify(data: any, pretty?: boolean | string): string {\n    let indent = \"\";\n\n    if (pretty) {\n        indent = typeof pretty == \"string\" ? pretty : \"  \";\n    }\n\n    return stringifyCommon(data, indent, indent, \"\", new Map<any, string>());\n}","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nvar strictMatch = require(\"./util\").strictMatch;\r\nvar escape = exports.escape = require(\"safe-string-literal\").escape;\r\nvar unescape = exports.unescape = require(\"safe-string-literal\").unescape;\r\n\r\nvar SINGLE_QUOTE = exports.SINGLE_QUOTE = \"'\";\r\nvar DOUBLE_QUOTE = exports.DOUBLE_QUOTE = '\"';\r\nvar BACK_QUOTE = exports.BACK_QUOTE = \"`\";\r\n\r\n/**\r\n * @param {string} str \r\n */\r\nfunction removeUnusedEscapes(str) {\r\n    var exludes = \"\\\\'\\\"`bfnrtux\";\r\n    return String(str).replace(/\\\\\\S/g, function (chars) {\r\n        if (!~exludes.indexOf(chars[1])) {\r\n            return chars[1];\r\n        } else {\r\n            return chars;\r\n        }\r\n    });\r\n}\r\n\r\nexports.parseToken = parseToken;\r\n/**\r\n * @param {string} str\r\n * @returns {{ source: string, offset: number, length: number, value: string, quote: \"'\" | \"\\\"\" | \"`\" }} \r\n */\r\nfunction parseToken(str) {\r\n    var token = { source: \"\", offset: -1, length: 0, value: \"\", quote: \"\" };\r\n    var matches = \"\";\r\n    var skippedLength = 0;\r\n\r\n    for (var i = 0; i < str.length; i++) {\r\n        var char = str[i];\r\n\r\n        if (char != false || token.quote) {\r\n            if (token.offset === -1) {\r\n                token.offset = i;\r\n            }\r\n\r\n            token.source += char;\r\n\r\n            if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE || char === BACK_QUOTE) {\r\n                matches += char;\r\n\r\n                if (!token.quote) {\r\n                    token.quote = char;\r\n                } else if (char === token.quote && str[i - 1] !== \"\\\\\") {\r\n                    break;\r\n                }\r\n            } else if (char === \"\\\\\") {\r\n                if (str[i + 1] === \"\\n\") {\r\n                    token.source += \"\\n\";\r\n                    skippedLength += 2;\r\n                    i++; // skip new line character of the string\r\n                } else {\r\n                    matches += char;\r\n                }\r\n            } else if (char === \"\\n\") {\r\n                if (token.quote === BACK_QUOTE) {\r\n                    matches += char;\r\n                } else if (str[i - 1] !== \"\\\\\") {\r\n                    return null;\r\n                } else {\r\n                    matches = matches.slice(0, -1);\r\n                    matches += char;\r\n                }\r\n            } else if (char !== \"\\n\" && token.quote) {\r\n                matches += char;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n\r\n    // token.source = matches;\r\n    token.value = matches && unescape(removeUnusedEscapes(matches.slice(1, -1)));\r\n    token.length = matches.length + skippedLength;\r\n    token.offset = token.offset === -1 ? 0 : token.offset;\r\n\r\n    if (strictMatch(str, token, /^\\s*[,;:)\\]}\\/]|^\\s*$/)) {\r\n        return token;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nexports.parse = parse;\r\n/**\r\n * @param {string} str \r\n */\r\nfunction parse(str) {\r\n    var token = parseToken(str);\r\n    return token ? token.value : undefined;\r\n}\r\n\r\nexports.toLiteral = toLiteral;\r\n/**\r\n * @param {string} str \r\n * @param {\"'\" | \"\\\"\" | \"`\"} quote \r\n */\r\nfunction toLiteral(str, quote) {\r\n    var exclues;\r\n    quote = quote || '\"';\r\n\r\n    if (quote === \"'\")\r\n        exclues = '\"`';\r\n    else if (quote === '\"')\r\n        exclues = \"'`\";\r\n    else if (quote === \"`\")\r\n        exclues = \"'\\\"\\n\";\r\n\r\n    return quote + escape(str, exclues) + quote;\r\n}","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nvar strictMatch = require(\"./util\").strictMatch;\r\nvar keyword = require(\"./keyword\");\r\n\r\nvar NUM_SEQUENCE = \"0123456789abcdefox-+.\";\r\n\r\nexports.BIN = 2;\r\nexports.OCT = 8;\r\nexports.DEC = 10;\r\nexports.HEX = 16;\r\n\r\nexports.parseToken = parseToken;\r\n/**\r\n * @param {string} str\r\n * @param {boolean} allowTrailings\r\n * @returns {{ source: string, offset: number, length: number, value: number, radix: 8 | 10 | 16 }} \r\n */\r\nfunction parseToken(str) {\r\n    var allowTrailings = arguments[1] || false;\r\n    var matches = \"\";\r\n    var token = { source: \"\", offset: -1, length: 0, value: NaN, radix: 0 };\r\n    var _token = keyword.parseToken(str);\r\n\r\n    if (_token) {\r\n        token = Object.assign(_token, { radix: 10 });\r\n\r\n        if (typeof token.value !== \"number\") {\r\n            return null;\r\n        }\r\n\r\n        return token;\r\n    }\r\n\r\n    for (var i = 0; i < str.length; i++) {\r\n        var char = str[i];\r\n\r\n        if (char != false || char === \"0\") {\r\n            if (token.offset === -1) {\r\n                token.offset = i;\r\n            }\r\n\r\n            var _char = char.toLowerCase();\r\n            var pos = NUM_SEQUENCE.indexOf(_char);\r\n\r\n            if (pos === -1) {\r\n                break;\r\n            } else if (_char === \"e\") {\r\n                if (token.radix === 16 || (\r\n                    token.radix === 10 && matches.indexOf(char) === -1)\r\n                ) {\r\n                    matches += char;\r\n                } else {\r\n                    break;\r\n                }\r\n            } else if (_char === \"b\" || _char === \"o\" || _char === \"x\") {\r\n                if ((matches.length === 1 && matches[0] === \"0\") || (\r\n                    matches.length === 2 && matches[1] === \"0\" && (\r\n                        matches[0] === \"-\" || matches[0] === \"+\"\r\n                    )\r\n                )) {\r\n                    token.radix = ({ b: 2, o: 8, x: 16 })[_char];\r\n                    matches += char;\r\n                } else if (_char === \"b\" && token.radix === 16) {\r\n                    matches += char;\r\n                } else {\r\n                    break;\r\n                }\r\n            } else if (pos < 8) {\r\n                if (matches.length === 0 || (\r\n                    matches.length === 1 && (\r\n                        matches[0] === \"-\" || matches[0] === \"+\"\r\n                    )\r\n                )) {\r\n                    if (char === \"0\") {\r\n                        token.radix = 8;\r\n                    } else {\r\n                        token.radix = 10;\r\n                    }\r\n                }\r\n                matches += char;\r\n            } else if (pos < 10) {\r\n                if (token.radix === 2 || token.radix === 8) {\r\n                    token.radix = 10;\r\n                }\r\n                matches += char;\r\n            } else if (pos < 16) {\r\n                if (token.radix === 16) {\r\n                    matches += char;\r\n                } else {\r\n                    break;\r\n                }\r\n            } else if (char === \".\") {\r\n                if (matches.length === 0) {\r\n                    token.radix = 10;\r\n                    matches += char;\r\n                } else if (token.radix === 10 && matches.indexOf(\".\") === -1) {\r\n                    matches += char;\r\n                } else {\r\n                    break;\r\n                }\r\n            } else { // -+\r\n                var prevChar = str[i - 1];\r\n                if (matches.length === 0 || ( // signed number\r\n                    prevChar === \"e\" || prevChar === \"E\" // scientific notation\r\n                )) {\r\n                    matches += char;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    token.source = matches;\r\n    token.length = matches.length;\r\n    token.offset = token.offset === -1 ? 0 : token.offset;\r\n\r\n    if (matches) {\r\n        if (token.radix === 8 && /[oO]/.test(matches) === false) {\r\n            token.value = parseInt(matches, 8);\r\n        } else if (token.radix !== 10) {\r\n            if (matches[0] === \"-\") {\r\n                token.value = -Number(matches.slice(1));\r\n            } else if (matches[0] === \"+\") {\r\n                token.value = Number(matches.slice(1));\r\n            } else {\r\n                token.value = Number(matches);\r\n            }\r\n        } else {\r\n            token.value = Number(matches);\r\n        }\r\n    }\r\n\r\n    var boundaries = token.radix === 10 ? /^\\s*[,;:)\\]}\\/]|^\\s*$/ : undefined;\r\n\r\n    if (isNaN(token.value) || (\r\n        !allowTrailings && !strictMatch(str, token, boundaries)\r\n    )) {\r\n        return null;\r\n    }\r\n\r\n    return token;\r\n}\r\n\r\nexports.parse = parse;\r\n/**\r\n * @param {string} str \r\n * @param {boolean} strict \r\n */\r\nfunction parse(str, strict) {\r\n    var token = parseToken(str, !strict);\r\n    return token ? token.value : undefined;\r\n}\r\n\r\nfunction isRadix(str, radix) {\r\n    var token = parseToken(str);\r\n    return token ? token.radix == radix : false;\r\n}\r\n\r\n/**\r\n * @param {string} str \r\n */\r\nexports.isBin = function isBin(str) {\r\n    return isRadix(str, 2);\r\n};\r\n\r\n/**\r\n * @param {string} str \r\n */\r\nexports.isOct = function isOct(str) {\r\n    return isRadix(str, 8);\r\n};\r\n\r\n/**\r\n * @param {string} str \r\n */\r\nexports.isDec = function isDec(str) {\r\n    return isRadix(str, 10);\r\n};\r\n\r\n/**\r\n * @param {string} str \r\n */\r\nexports.isHex = function isHex(str) {\r\n    return isRadix(str, 16);\r\n};\r\n\r\n/**\r\n * @param {string} str \r\n */\r\nexports.isNaN = function isNaN(str) {\r\n    var value = parse(str, true);\r\n    return value === undefined || Number.isNaN(value);\r\n};\r\n\r\n/**\r\n * @param {string} str \r\n */\r\nexports.isFinite = function isFinite(str) {\r\n    return Number.isFinite(parse(str, true));\r\n};\r\n\r\n/**\r\n * @param {number} num\r\n * @param {2 | 8 | 10 | 16} radix\r\n */\r\nexports.toLiteral = function toLiteral(num, radix) {\r\n    if (Number.isNaN(num) || num === Infinity) {\r\n        return keyword.toLiteral(num);\r\n    } else {\r\n        radix = radix || 10;\r\n        return ({ 2: \"0b\", 8: \"0o\", 10: \"\", 16: \"0x\" })[radix] + num.toString(radix);\r\n    }\r\n};","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nvar strictMatch = require(\"./util\").strictMatch;\r\n\r\nvar FLAGS = \"gimsuy\";\r\n\r\nexports.parseToken = parseToken;\r\n/**\r\n * \r\n * @param {string} str \r\n * @returns {{ source: string, offset: number, length: number, value: RegExp }}\r\n */\r\nfunction parseToken(str) {\r\n    var token = { value: null, offset: -1, length: 0 };\r\n    var source = \"\";\r\n    var flags = \"\";\r\n    var closed = false;\r\n\r\n    for (var i = 0; i < str.length; i++) {\r\n        var char = str[i];\r\n\r\n        if (char != false) {\r\n            if (token.offset === -1) {\r\n                token.offset = i;\r\n            }\r\n\r\n            if (char === \"/\") {\r\n                if (source.length === 0 || str[i - 1] === \"\\\\\") {\r\n                    source += char;\r\n                } else if (closed) {\r\n                    return null;\r\n                } else {\r\n                    source += char;\r\n                    closed = true;\r\n                }\r\n            } else if (source[0] !== \"/\") {\r\n                return null;\r\n            } else if (closed && FLAGS.indexOf(char) >= 0 && !~flags.indexOf(char)) {\r\n                flags += char;\r\n            } else if (!closed) {\r\n                source += char;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    token.source = source + flags;\r\n    token.offset = token.offset === -1 ? 0 : token.offset;\r\n    token.length = source.length + flags.length;\r\n\r\n    try {\r\n        token.value = new RegExp(source.slice(1, -1), flags);\r\n    } catch (e) {\r\n        return null;\r\n    }\r\n\r\n    if (!strictMatch(str, token)) {\r\n        return null;\r\n    }\r\n\r\n    return token;\r\n}\r\n\r\n/**\r\n * @param {string} str\r\n */\r\nexports.parse = function parse(str) {\r\n    var token = parseToken(str);\r\n    return token ? token.value : undefined;\r\n};\r\n\r\n/**\r\n * @param {RegExp} re\r\n */\r\nexports.toLiteral = function toLiteral(re) {\r\n    return String(re);\r\n}","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nvar INLINE_COMMENT = /^\\s*\\/\\/.*\\n*?/;\r\nvar MULTI_LINE_COMMENT = /^\\s*\\/\\*[\\s\\S]*?\\*\\//;\r\n\r\nexports.parseToken = parseToken;\r\n/**\r\n * @param {string} str\r\n * @returns {{ source: string, offset: number, length: number, value: string, type: \"//\" | \"/*\" | \"/**\" }} \r\n */\r\nfunction parseToken(str) {\r\n    var token = { source: \"\", offset: 0, length: 0, value: \"\", type: \"\" };\r\n    var match = INLINE_COMMENT.exec(str) || MULTI_LINE_COMMENT.exec(str);\r\n\r\n    if (match) {\r\n        token.offset = match[0].indexOf(\"/\");\r\n        token.length = match[0].length - token.offset;\r\n        token.source = token.value = match[0].slice(token.offset);\r\n\r\n        if (token.value[1] === \"/\") {\r\n            token.type = \"//\";\r\n        } else if (token.value.slice(1, 3) === \"**\") {\r\n            token.type = \"/**\"\r\n        } else {\r\n            token.type = \"/*\";\r\n        }\r\n\r\n        return token;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * @param {string} str \r\n * @param {boolean} strip Strip meaningless characters.\r\n */\r\nexports.parse = function parse(str, strip) {\r\n    var token = parseToken(str);\r\n\r\n    if (!token) return;\r\n\r\n    if (!strip) {\r\n        return token.value;\r\n    } else if (token.type === \"//\") {\r\n        return token.value.replace(/^\\/\\/\\s*/, \"\");\r\n    } else {\r\n        var lines = token.value.replace(/\\s*\\*\\/$/, \"\").split(\"\\n\");\r\n        var value = lines[0].replace(/^\\/\\*\\s*/, \"\");\r\n        var isNewLine = false;\r\n\r\n        for (var i = 1; i < lines.length; i++) {\r\n            if (/^[\\s\\*]*$/.test(lines[i])) {\r\n                if (!isNewLine) {\r\n                    value += \"\\n\";\r\n                    isNewLine = true;\r\n                }\r\n            } else {\r\n                value += (isNewLine ? \"\" : \" \") + lines[i].replace(/^[\\s\\*]*/, \"\");\r\n                isNewLine = false;\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n};\r\n\r\n/**\r\n * @param {string} str\r\n * @param {\"//\" | \"/*\" | \"/**\"} type\r\n * @param {string} indent Indent all rest lines of the comment with the given spaces.\r\n */\r\nexports.toLiteral = function toLiteral(str, type, indent) {\r\n    type = type || \"//\";\r\n    indent = indent || \"\";\r\n\r\n    var hasMultiLine = str.indexOf(\"\\n\") >= 0;\r\n\r\n    if (!hasMultiLine) {\r\n        if (type === \"//\") {\r\n            return \"// \" + str;\r\n        } else {\r\n            return type + \" \" + str + \" */\";\r\n        }\r\n    } else {\r\n        var lines = str.split(\"\\n\");\r\n\r\n        if (type === \"//\") {\r\n            lines[0] = \"// \" + lines[0];\r\n        } else {\r\n            lines.unshift(type);\r\n        }\r\n\r\n        for (var i = 1; i < lines.length; i++) {\r\n            lines[i] = lines[i].replace(/^\\s*/, \"\");\r\n\r\n            if (type == \"//\") {\r\n                lines[i] = indent + \"// \" + lines[i];\r\n            } else {\r\n                lines[i] = indent + \" * \" + lines[i];\r\n            }\r\n        }\r\n\r\n        if (type !== \"//\") {\r\n            lines.push(indent + \" */\");\r\n        }\r\n\r\n        return lines.join(\"\\n\");\r\n    }\r\n};","module.exports = require(\"assert\");","import get = require(\"get-value\");\nimport set = require(\"set-value\");\nimport { pick } from \"./util\";\nimport { Variable, CompoundTypes, getInstance, IsNode } from \"./types\";\nimport {\n    LiteralToken,\n    string,\n    number,\n    regexp,\n    comment,\n    keyword\n} from 'literal-toolkit';\n\n/** A pattern to match Latin properties or type notations. */\nexport const TypeOrPorp = /^([a-z_][a-z0-9_]*)\\s*[:\\(]/i;\n\n/**\n * The interface that carries token details in the FRON string (source), e.g.\n * `filename`, `position`, `type` etc.\n */\nexport interface SourceToken {\n    /**\n     * The filename that parsed to the parser, if no filename is parsed, the \n     * default value will be `<anonymous>`.\n     */\n    filename: string;\n    /**\n     * The appearing position of the current token, includes both start and end \n     * positions.\n     */\n    position: {\n        start: {\n            line: number,\n            column: number\n        };\n        end: {\n            line: number,\n            column: number\n        };\n    };\n    /**\n     * The type of the current token, literal types are lower-cased and compound\n     * types are upper-cased.\n     */\n    type: string;\n    /**\n     * The parsed data of the current token, it may not be the final data since\n     * there may be a handler to deal with the current type.\n     */\n    data: any;\n    /** The token of the parent node. */\n    parent?: SourceToken;\n    /**\n     * The path of the current token, only for object properties and array \n     * elements.\n     */\n    path?: string;\n    /**\n     * All the comments in the current token. When parsing a comment token, it \n     * will be appended to the closest parent node, unless the comment is the \n     * very first token. Comments are not important to the parser and will be \n     * skipped when composing data.\n     */\n    comments?: SourceToken[];\n}\n\n/**\n * SourceToken is a class constructor as well, it is used to distinguish \n * the token object from all objects.\n */\nexport class SourceToken implements SourceToken {\n    constructor(token: SourceToken) {\n        Object.assign(this, token);\n    }\n}\n\n/** Carries details of the current position of the parsing cursor. */\nexport interface CursorToken {\n    index: number;\n    line: number;\n    column: number;\n    filename: string;\n}\n\n/**\n * Throws syntax error when the current token is invalid and terminate the \n * parser immediately.\n */\nexport function throwSyntaxError(token: SourceToken, char: string) {\n    let filename = token.filename,\n        type = token.type ? token.type + \" token\" : \"token \" + char,\n        { line, column } = token.position.start;\n    throw new SyntaxError(`Unexpected ${type} in ${filename}:${line}:${column}`);\n}\n\n/**\n * Gets the customized handler of the given type for parsing, may return \n * undefined if no handler is registered.\n */\nexport function getHandler(type: string): (data: any) => any {\n    return get(CompoundTypes[type], \"prototype.fromFRON\");\n}\n\n/**\n * Normalizes the given path, resolving '..' and '.' segments, and change path\n * separators to platform preference.\n */\nfunction normalizePath(path: string): string {\n    let parts = path.split(/\\/|\\\\/),\n        sep = IsNode ? \"/\" : (process.platform == \"win32\" ? \"\\\\\" : \"/\");\n\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        } else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n\n    return parts.join(sep);\n}\n\n/** Gets the last elements of an array-like object. */\nfunction last<T>(target: ArrayLike<T>): T {\n    return target[target.length - 1];\n}\n\n/** Parses every token in the FRON string. */\nfunction doParseToken(\n    str: string,\n    parent: SourceToken,\n    cursor: CursorToken,\n    listener?: (token: SourceToken) => void\n): SourceToken {\n    let char: string;\n    let token: SourceToken;\n\n    loop:\n    while ((char = str[cursor.index])) {\n        if (<any>char == false && char !== \"0\") {\n            // For falsy characters (except string '0'), only move the cursor \n            // forward, and do not parse any tokens.\n\n            cursor.index++;\n\n            if (char === \"\\n\") {\n                // Meet new line, increase the line number and move the column \n                // to the line head.\n                cursor.line++;\n                cursor.column = 1;\n            } else {\n                // Otherwise increase the column number only.\n                cursor.column++;\n            }\n\n            continue;\n        }\n\n        let remains: string,\n            dataToken: LiteralToken & { value: any, type?: string };\n\n        // Use a SourceToken instance, so that it could be distinguished from\n        // common objects.\n        token = new SourceToken({\n            filename: cursor.filename,\n            position: {\n                start: pick(cursor, [\"line\", \"column\"]),\n                end: undefined\n            },\n            type: undefined,\n            data: undefined,\n        });\n\n        // Using this method, so that the parent property won't be always showed\n        // up on the token.\n        if (parent) token.parent = parent;\n\n        switch (char) {\n            case \",\":\n                // A comma (`,`) appears right after a property value in an \n                // object, or an element in an array.\n                if (parent && [\"Object\", \"Array\"].indexOf(parent.type) >= 0) {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \":\":\n                // A colon (`:`) appears right after a property name in an \n                // object.\n                if (parent && parent.type === \"property\") {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \"(\":\n                // The open bracket (`(`) appears right after a compound type \n                // name, which will be parsed as an individual token, and the \n                // bracket only indicates that it's the beginning of the type \n                // container. A compound type notation uses a type name and a \n                // pair of brackets to form a container, inside the container, \n                // is an pure object literal or array literal.\n                // The parent here is the very type name node of the compound \n                // type notation.\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \")\":\n                // The closing bracket (`)`) indicates the end position of a \n                // compound type container, see above.\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++\n                } else {\n                    throwSyntaxError(token, char);\n                }\n\n                // Break the loop means the current node has been fully parsed,\n                // if the node is not yet fully parsed, should just break the \n                // switch block and continue parsing. Once a token has been \n                // fully parsed, break the loop and go to the end of the \n                // function for summary, gather and fill the token details. \n                break loop;\n\n            case \"{\": // object\n            case \"[\": // array\n                // Like the very JavaScript style, an object literal uses a pair\n                // of curly braces to contain key-value pairs, and an array\n                // literal uses a pair of square brackets to contain elements.\n                let isArray = char === \"[\";\n\n                cursor.index++;\n                cursor.column++;\n                token.type = isArray ? \"Array\" : \"Object\";\n                token.data = isArray ? [] : {};\n\n                // Objects and arrays contains sub-nodes (inner tokens), so \n                // recursively calling `doParseToken` to parse them before \n                // parsing continuing tokens. Since the cursor is a reference,\n                // not a copy, when parsing inner tokens and move the cursor, \n                // the outside node will follow the cursor, and keep parsing\n                // from where the inner nodes ends.\n                doParseToken(str, token, cursor, listener);\n                break loop;\n\n            case \"}\": // closing sign of an object\n            case \"]\": // closing sign of an array\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n\n                // The closing bracket of an object or array indicates the \n                // \"block\" is finished, and should no longer try to parse \n                // remaining tokens since they don't belong to the object or the\n                // array. `doParseToken()` will try to parse remaining tokens\n                // once a former token is parsed, since we don't need to parse \n                // them, return immediately to prevent that happens. \n                return;\n\n            case \"'\": // single-quoted string\n            case '\"': // double-quoted string\n            case \"`\": // back-quoted string\n                // Once a token type has been identified, assign it to the token\n                // object immediately, so that when even the token is invalid \n                // and throw a syntax error, the error can still tell what kind \n                // of token that is.\n                token.type = \"string\";\n\n                if ((dataToken = string.parseToken(str.slice(cursor.index)))) {\n                    let lines = dataToken.source.split(\"\\n\");\n\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.line += lines.length - 1;\n\n                    if (lines.length > 1) {\n                        // If the string takes multiple lines, move the column \n                        // number to the end of the last line.\n                        cursor.column = last(lines).length + 1;\n                    } else {\n                        cursor.column += dataToken.length;\n                    }\n                } else {\n                    console.log(str.slice(cursor.index));\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n\n            case \"/\": // regular expression or comment\n                token.type = \"regexp\";\n                remains = str.slice(cursor.index);\n\n                if ((dataToken = regexp.parseToken(remains))) { // regexp\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if ((dataToken = comment.parseToken(remains))) { // comment\n                    token.type = \"comment\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n\n                    if (dataToken.type !== \"//\") {\n                        // Multi-line comment starts with `/*` or `/**`.\n                        let lines = dataToken.source.split(\"\\n\");\n                        cursor.line += lines.length - 1;\n\n                        if (lines.length > 1) {\n                            cursor.column = last(lines).length + 1;\n                        } else {\n                            cursor.column += dataToken.length;\n                        }\n                    }\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n\n            default:\n                remains = str.slice(cursor.index);\n                let matches: RegExpMatchArray;\n\n                if ((dataToken = number.parseToken(remains))) { // number\n                    token.type = \"number\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if ((dataToken = keyword.parseToken(remains))) { // keyword\n                    token.type = \"keyword\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if (matches = remains.match(TypeOrPorp)) {\n                    let lines = matches[0].split(\"\\n\"),\n                        key = matches[1];\n\n                    cursor.index += key.length;\n                    cursor.line += lines.length - 1;\n\n                    if (lines.length > 1) {\n                        // If there are new lines between the property (or type \n                        // name) and the colon(or open bracket), move the column\n                        // number to the head of the line.\n                        cursor.column = 1;\n                    } else {\n                        cursor.column += key.length;\n                    }\n\n                    if (last(matches[0]) === \":\") { // property\n                        token.type = \"property\";\n\n                        // A property can only appears inside an object.\n                        if (parent && parent.type === \"Object\") {\n                            token.data = key;\n                        } else {\n                            throwSyntaxError(token, char);\n                        }\n                    } else { // compound type\n                        token.type = key;\n\n                        if (!parent && token.type === \"Reference\") {\n                            // A reference type con only appears inside a \n                            // compound type (object, array or something else).\n                            throwSyntaxError(token, char);\n                        } else {\n                            token.data = doParseToken(\n                                str,\n                                token,\n                                cursor,\n                                listener\n                            );\n\n                            // Since the token of a customized compound type \n                            // contains an extra closing bracket \")\", and \n                            // potential spaces, using doParseToken() can let \n                            // the cursor travel through them.\n                            doParseToken(str, token, cursor);\n                        }\n                    }\n                } else {\n                    isFinite(Number(char)) && (token.type = \"number\");\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n        }\n    }\n\n    token.position.end = pick(cursor, [\"line\", \"column\"]);\n\n    if (token.parent && token.type === \"comment\") {\n        token.parent.comments = token.parent.comments || [];\n        token.parent.comments.push(token);\n    } else if (token.parent && token.parent.type === \"Object\") { // object\n        let prop = token.data,\n            isVar = Variable.test(prop),\n            prefix = get(token, \"parent.parent.path\", \"\"),\n            path = isVar ? (prefix ? \".\" : \"\") + `${prop}` : `['${prop}']`;\n\n        // If the parent node is an object, that means the current node is a \n        // property node, should set the path and parse the property value as a\n        // child node.\n        token.path = (prefix || \"\") + path;\n        token.type = \"property\";\n\n        // Use a while block to parse the property value token, in case there \n        // are comments before the value node.\n        while (token.data = doParseToken(str, token, cursor, listener)) {\n            if (!token.data || token.data.type !== \"comment\") break;\n        }\n\n        // Append the current node to the parent node as a new property. \n        token.parent.data[prop] = token;\n    } else if (token.parent && token.parent.type === \"Array\") { // array\n        let prefix = get(token, \"parent.path\", \"\");\n\n        // If the parent node is an array, append the current node to the parent\n        // node as its element.\n        token.path = `${prefix}[${token.parent.data.length}]`;\n        token.parent.data.push(token);\n    }\n\n    // If there is a listener bound, call it to watch all parsing moments.\n    listener && listener.call(void 0, token);\n\n    if (token.parent && [\"Object\", \"Array\"].indexOf(token.parent.type) >= 0) {\n        // If the parent node is either object or array, try to parse remaining \n        // tokens as its properties (or elements).\n        return doParseToken(str, token.parent, cursor, listener);\n    } else {\n        return token;\n    }\n}\n\n/**\n * Composes all tokens (include children nodes) to a JavaScript object and \n * gather all references into a map.\n */\nfunction compose(token: SourceToken, refMap: { [path: string]: string }): any {\n    let data: any;\n\n    switch (token.type) {\n        case \"Object\":\n            data = {};\n            for (let prop in token.data) {\n                // Every property in an object token is also SourceToken, which\n                // should be composed recursively.\n                data[prop] = compose(token.data[prop].data, refMap);\n            }\n            break;\n\n        case \"Array\":\n            data = [];\n            for (let item of token.data) {\n                // Every element in an array token is also SourceToken, which\n                // should be composed recursively.\n                data.push(compose(item, refMap));\n            }\n            break;\n\n        case \"Reference\":\n            // The data contained by Reference is a SourceToken with string,\n            // which should be composed first before using it.\n            refMap[token.parent.path] = compose(token.data, refMap);\n            break;\n\n        default:\n            if (token.data instanceof SourceToken) {\n                let handle = getHandler(token.type),\n                    inst = getInstance(token.type);\n\n                data = compose(token.data, refMap); // try to compose first\n\n                // Try to call registered parsing handler to get expected data.\n                data = handle\n                    ? handle.call(inst || data, data)\n                    : data;\n            } else if (token.type !== \"comment\") {\n                data = token.data;\n            }\n            break;\n    }\n\n    return data;\n}\n\n/** Composes a token or token tree to a JavaScript object. */\nexport function composeToken(token: SourceToken): any {\n    let refMap = {},\n        data = compose(token, refMap);\n\n    // Sets all references according to the map.\n    for (let path in refMap) {\n        let target = refMap[path];\n        let ref = target ? get(data, target) : data;\n        set(data, path, ref);\n    }\n\n    return data;\n}\n\n/**\n * Parses the given FRON string into a well-constructed token or token tree.\n * @param filename When parsing data from a file, given that filename to the \n *  parser, so that if the parser throws syntax error, it could address the \n *  position properly. The default value is `<anonymous>`.\n * @param listener If set, it will be called when parsing every token in the \n *  FRON string, and be helpful for programmatic usage.\n */\nexport function parseToken(\n    str: string,\n    filename?: string,\n    listener?: (token: SourceToken) => void\n): SourceToken {\n    return str ? doParseToken(str, null, {\n        index: 0,\n        line: 1,\n        column: 1,\n        filename: filename ? normalizePath(filename) : \"<anonymous>\"\n    }, listener) : null;\n}\n\n/**\n * Parses the given FRON string to JavaScript object.\n * @param filename When parsing data from a file, given that filename to the \n *  parser, so that if the parser throws syntax error, it could address the \n *  position properly. The default value is `<anonymous>`.\n */\nexport function parse(str: string, filename?: string): any {\n    return str ? composeToken(parseToken(str, filename)) : void 0;\n}","/*!\n * set-value <https://github.com/jonschlinkert/set-value>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isPlain = require('is-plain-object');\n\nfunction set(target, path, value, options) {\n  if (!isObject(target)) {\n    return target;\n  }\n\n  let opts = options || {};\n  const isArray = Array.isArray(path);\n  if (!isArray && typeof path !== 'string') {\n    return target;\n  }\n\n  let merge = opts.merge;\n  if (merge && typeof merge !== 'function') {\n    merge = Object.assign;\n  }\n\n  const keys = isArray ? path : split(path, opts);\n  const len = keys.length;\n  const orig = target;\n\n  if (!options && keys.length === 1) {\n    result(target, keys[0], value, merge);\n    return target;\n  }\n\n  for (let i = 0; i < len; i++) {\n    let prop = keys[i];\n\n    if (!isObject(target[prop])) {\n      target[prop] = {};\n    }\n\n    if (i === len - 1) {\n      result(target, prop, value, merge);\n      break;\n    }\n\n    target = target[prop];\n  }\n\n  return orig;\n}\n\nfunction result(target, path, value, merge) {\n  if (merge && isPlain(target[path]) && isPlain(value)) {\n    target[path] = merge({}, target[path], value);\n  } else {\n    target[path] = value;\n  }\n}\n\nfunction split(path, options) {\n  const id = createKey(path, options);\n  if (set.memo[id]) return set.memo[id];\n\n  const char = (options && options.separator) ? options.separator : '.';\n  let keys = [];\n  let res = [];\n\n  if (options && typeof options.split === 'function') {\n    keys = options.split(path);\n  } else {\n    keys = path.split(char);\n  }\n\n  for (let i = 0; i < keys.length; i++) {\n    let prop = keys[i];\n    while (prop && prop.slice(-1) === '\\\\' && keys[i + 1]) {\n      prop = prop.slice(0, -1) + char + keys[++i];\n    }\n    res.push(prop);\n  }\n  set.memo[id] = res;\n  return res;\n}\n\nfunction createKey(pattern, options) {\n  let id = pattern;\n  if (typeof options === 'undefined') {\n    return id + '';\n  }\n  const keys = Object.keys(options);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    id += ';' + key + '=' + String(options[key]);\n  }\n  return id;\n}\n\nfunction isObject(val) {\n  switch (typeof val) {\n    case 'null':\n      return false;\n    case 'object':\n      return true;\n    case 'function':\n      return true;\n    default: {\n      return false;\n    }\n  }\n}\n\nset.memo = {};\nmodule.exports = set;\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n"],"sourceRoot":""}