{"version":3,"sources":["webpack://FRON/webpack/universalModuleDefinition","webpack://FRON/webpack/bootstrap","webpack://FRON/./node_modules/get-value/index.js","webpack://FRON/./node_modules/literal-toolkit/lib/util.js","webpack://FRON/./src/util.ts","webpack://FRON/./src/types.ts","webpack://FRON/./node_modules/isobject/index.js","webpack://FRON/./node_modules/literal-toolkit/index.js","webpack://FRON/./node_modules/safe-string-literal/index.js","webpack://FRON/./node_modules/literal-toolkit/lib/keyword.js","webpack://FRON/./src/index.ts","webpack://FRON/./src/stringify.ts","webpack://FRON/./node_modules/literal-toolkit/lib/string.js","webpack://FRON/./node_modules/literal-toolkit/lib/number.js","webpack://FRON/./node_modules/literal-toolkit/lib/regexp.js","webpack://FRON/./node_modules/literal-toolkit/lib/comment.js","webpack://FRON/external \"assert\"","webpack://FRON/./src/parse.ts","webpack://FRON/./node_modules/set-value/index.js","webpack://FRON/./node_modules/is-plain-object/index.js"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","isObject","join","segs","joinChar","options","isValid","target","isValidObject","val","Array","isArray","path","default","String","isString","splitChar","separator","split","len","length","idx","prop","slice","hasProp","BOUNDARIES","strictMatch","str","token","boundaries","arguments","leftOver","offset","test","keys","obj","proto","getPrototypeOf","Reflect","ownKeys","concat","filter","pass","IsNode","global","LatinVar","values","data","arr","iterator","item","push","pick","props","result","indexOf","omit","last","normalize","parts","sep","process","platform","splice","util_1","CompoundTypes","getType","undefined","ctor","type","getInstance","FRONEntryBase","[object Object]","assign","FRONString","checkProto","fromFRON","TypeError","checkType","ReferenceError","copyProto","source","register","Error","constructor","keyFor","for","Number","Boolean","forEach","valueOf","RegExp","toString","flags","Date","toISOString","Map","Set","Int8Array","Int16Array","Int32Array","Uint8Array","Uint16Array","Uint32Array","from","EvalError","RangeError","SyntaxError","reserved","defineProperties","writable","configurable","message","stack","AssertionError","Buffer","string","number","keyword","regexp","comment","escape","excludes","replace","char","unescape","chars","KEYWORDS","parseToken","match","exec","parse","toLiteral","stringify_1","stringify","parse_1","composeToken","SourceToken","types_1","literal_toolkit_1","stringifyCommon","indent","originalIndent","refMap","getHandler","has","set","handlers","container","toFRON","x","isVar","res","handler","apply","pretty","SINGLE_QUOTE","DOUBLE_QUOTE","BACK_QUOTE","quote","matches","skippedLength","removeUnusedEscapes","exclues","NUM_SEQUENCE","allowTrailings","NaN","radix","_token","_char","toLowerCase","pos","b","prevChar","parseInt","isNaN","strict","isRadix","BIN","OCT","DEC","HEX","isBin","isOct","isDec","isHex","isFinite","num","Infinity","2","8","10","16","FLAGS","closed","e","re","INLINE_COMMENT","MULTI_LINE_COMMENT","strip","lines","isNewLine","unshift","require","TypeOrPorp","throwSyntaxError","filename","line","column","position","start","compose","parent","handle","inst","ref","listener","doParseToken","cursor","loop","index","remains","dataToken","end","console","log","comments","prefix","isPlain","opts","merge","id","pattern","createKey","memo","orig","isObjectObject","prot"],"mappings":"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","file":"fron.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"FRON\"] = factory();\n\telse\n\t\troot[\"FRON\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","/*!\n * get-value <https://github.com/jonschlinkert/get-value>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isObject = require('isobject');\n\nmodule.exports = function(target, path, options) {\n  if (!isObject(options)) {\n    options = { default: options };\n  }\n\n  if (!isValidObject(target)) {\n    return typeof options.default !== 'undefined' ? options.default : target;\n  }\n\n  if (typeof path === 'number') {\n    path = String(path);\n  }\n\n  const isArray = Array.isArray(path);\n  const isString = typeof path === 'string';\n  const splitChar = options.separator || '.';\n  const joinChar = options.joinChar || (typeof splitChar === 'string' ? splitChar : '.');\n\n  if (!isString && !isArray) {\n    return target;\n  }\n\n  if (isString && path in target) {\n    return isValid(path, target, options) ? target[path] : options.default;\n  }\n\n  let segs = isArray ? path : split(path, splitChar, options);\n  let len = segs.length;\n  let idx = 0;\n\n  do {\n    let prop = segs[idx];\n    if (typeof prop === 'number') {\n      prop = String(prop);\n    }\n\n    while (prop && prop.slice(-1) === '\\\\') {\n      prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options);\n    }\n\n    if (prop in target) {\n      if (!isValid(prop, target, options)) {\n        return options.default;\n      }\n\n      target = target[prop];\n    } else {\n      let hasProp = false;\n      let n = idx + 1;\n\n      while (n < len) {\n        prop = join([prop, segs[n++]], joinChar, options);\n\n        if ((hasProp = prop in target)) {\n          if (!isValid(prop, target, options)) {\n            return options.default;\n          }\n\n          target = target[prop];\n          idx = n - 1;\n          break;\n        }\n      }\n\n      if (!hasProp) {\n        return options.default;\n      }\n    }\n  } while (++idx < len && isValidObject(target));\n\n  if (idx === len) {\n    return target;\n  }\n\n  return options.default;\n};\n\nfunction join(segs, joinChar, options) {\n  if (typeof options.join === 'function') {\n    return options.join(segs);\n  }\n  return segs[0] + joinChar + segs[1];\n}\n\nfunction split(path, splitChar, options) {\n  if (typeof options.split === 'function') {\n    return options.split(path);\n  }\n  return path.split(splitChar);\n}\n\nfunction isValid(key, target, options) {\n  if (typeof options.isValid === 'function') {\n    return options.isValid(key, target);\n  }\n  return true;\n}\n\nfunction isValidObject(val) {\n  return isObject(val) || Array.isArray(val) || typeof val === 'function';\n}\n","var BOUNDARIES = /^\\s*[,;)\\]}\\/]|^\\s*$/;\n\nexports.strictMatch = strictMatch;\n/**\n * @param {string} str \n * @param {{ offset: number, length: number }} token \n */\nfunction strictMatch(str, token) {\n    var boundaries = arguments[2] || BOUNDARIES;\n    var leftOver = str.slice(token.offset + token.length);\n    return !leftOver || boundaries.test(leftOver);\n}","import get = require(\"get-value\");\n\n/** Whether the current environment is NodeJS. */\nexport const IsNode = typeof global === \"object\"\n    && get(global, \"process.release.name\") === \"node\";\n\n/** The pattern that matches valid JavaScript Latin variable names. */\nexport const LatinVar = /^[a-z_][a-z0-9_]*$/i;\n\n/**\n * Gets all properties of an object, including those inherited from prototype.\n */\nexport function keys(obj: any) {\n    let proto = Object.getPrototypeOf(obj);\n\n    return Reflect.ownKeys(obj).concat(\n        Reflect.ownKeys(proto).filter(key => {\n            if (typeof key === \"string\" && key.slice(0, 2) === \"__\") {\n                return false;\n            } else {\n                let pass = false;\n\n                try {\n                    pass = typeof proto[key] !== \"function\";\n                } finally {\n                    return pass;\n                }\n            }\n        })\n    );\n}\n\n/** Gets the values in the given iterable object. */\nexport function values<T>(data: Iterable<T> | { [x: string]: T }) {\n    let arr: T[] = [];\n\n    if (typeof data[Symbol.iterator] === \"function\") {\n        for (let item of (<Iterable<T>>data)) {\n            arr.push(item);\n        }\n    } else {\n        for (let key of keys(data)) {\n            arr.push(data[key]);\n        }\n    }\n\n    return arr;\n}\n\n/** Gets a copy of an object with only the specified keys. */\nexport function pick(obj: any, props: (string | number | symbol)[]): any {\n    let result = {};\n\n    for (let key of keys(obj)) {\n        if (props.indexOf(key) >= 0) {\n            result[key] = obj[key];\n        }\n    }\n\n    return result;\n}\n\n/** Gets a copy of an object without the specified keys. */\nexport function omit(obj: any, props: (string | number | symbol)[]): any {\n    let result = {};\n\n    for (let key of keys(obj)) {\n        if (props.indexOf(key) === -1) {\n            result[key] = obj[key];\n        }\n    }\n\n    return result;\n}\n\n/** Gets the last elements of an array-like object. */\nexport function last<T>(target: ArrayLike<T>): T {\n    return target[target.length - 1];\n}\n\n/**\n * Normalizes the given path, resolving '..' and '.' segments, and change path\n * separators to platform preference.\n */\nexport function normalize(path: string): string {\n    let parts = path.split(/\\/|\\\\/),\n        sep = IsNode ? \"/\" : (process.platform == \"win32\" ? \"\\\\\" : \"/\");\n\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] == \"..\") {\n            parts.splice(i - 1, 2);\n            i -= 2;\n        } else if (parts[i] == \".\") {\n            parts.splice(i, 1);\n            i -= 1;\n        }\n    }\n\n    return parts.join(sep);\n}","import get = require(\"get-value\");\nimport { pick, omit, values, IsNode } from \"./util\";\n\n/**\n * The interface restricts if a user defined type can be registered as FRON type.\n */\nexport interface FRONEntry {\n    toFRON?(): any;\n    fromFRON(data: any): any;\n};\n\n/** Indicates a class constructor that implements the FRONEntry interface. */\nexport type FRONConstructor = new (...args: any[]) => FRONEntry;\n\n/** \n * Stores all supported compound types, includes the types that user registered.\n */\nexport const CompoundTypes: { [type: string]: FRONConstructor } = {\n    // objects and arrays are handled internally by the stringifier and parser,\n    // register here is for checkers to identify them as compound types.\n    Object: <any>Object,\n    Array: <any>Object\n};\n\n/**\n * Gets the type name in string of the input data, may return a literal type \n * or a compound type.\n */\nexport function getType(data: any): string {\n    if (data === undefined) {\n        return;\n    } else if (data === null) {\n        return \"null\";\n    } else {\n        let type = typeof data,\n            ctor: FRONConstructor;\n\n        if (type !== \"object\") {\n            return type === \"symbol\" ? \"Symbol\" : type;\n        } else if (ctor = get(data, \"constructor\")) {\n            for (let type in CompoundTypes) {\n                if (ctor === CompoundTypes[type])\n                    return type;\n            }\n\n            return ctor.name;\n        }\n    }\n}\n\n/**\n * Gets an instance of the given type, may return undefined if the type isn't \n * registered, this function calls `Object.create()` to create instance, so the\n * constructor will not be called automatically.\n * \n * NOTE: This function may return `undefined` if the given type isn't registered.\n */\nexport function getInstance<T = any>(\n    type: string | (new (...args: any[]) => T)\n): T {\n    type = typeof type === \"function\" ? type.name : type;\n    return CompoundTypes[type] && Object.create(CompoundTypes[type].prototype);\n}\n\n/**\n * When register a type with an object as its prototype, a new sub-class will \n * be created to extend FRONEntryBase and merge the object to its prototype. In \n * the parsing phase, a FRONEntryBase instance will be created via \n * `Object.create()` and apply the `fromFRON()` method to it.\n */\nexport class FRONEntryBase implements FRONEntry {\n    toFRON() {\n        return Object.assign({}, this);\n    }\n\n    fromFRON(data: any) {\n        return data;\n    }\n}\n\n/**\n * A special type used to mark up user defined FRON notations, if a `toFRON()`\n * method return a `FRONString`, them it will not be stringified again with\n * common approach, just use the represented value as the output notation.\n * NOTE: the personalized notation must use valid syntax that can be identified \n * by the parser, it is either a literal, or a compound type.\n */\nexport class FRONString extends String { }\n\n/** Checks if the given prototype can be registered as an FRON type. */\nfunction checkProto(name: string, proto: FRONEntry) {\n    if (typeof proto.fromFRON !== \"function\") {\n        // Every constructor that used as FRON type should include a \n        // `fromFRON()` method, so that when parsing the FRON string, the parser\n        // could call the method to produce an expected instance of the type.\n        throw new TypeError(`prototype method ${name}.fromFRON() is missing`);\n    } else if (proto.fromFRON.length < 1) {\n        // The `fromFRON()` method needs to accept at least one argument, which \n        // is the data parsed from the FRON string, usually used to create a new\n        // instance of the type.\n        // The second argument `type` is optional, when pass, it is the type \n        // notation in string of the token.\n        throw new TypeError(`prototype method ${name}.fromFRON() is invalid`);\n    }\n}\n\n/** Checks if a type is registered. */\nfunction checkType(type: string | FRONConstructor) {\n    type = typeof type === \"string\" ? type : type.name;\n    if (!CompoundTypes[type]) {\n        throw new ReferenceError(`Unrecognized type: ${type}`);\n    }\n}\n\n/**\n * Copies the FRONEntry protocol methods from a FRONConstructor to another \n * constructor.\n */\nfunction copyProto(source: object | FRONConstructor, target: Function) {\n    source = typeof source === \"function\" ? source.prototype : source;\n    Object.assign(target.prototype, pick(source, [\n        \"toFRON\",\n        \"fromFRON\"\n    ]));\n}\n\n/**\n * Registers a customized data type so that the stringifier and parser can \n * identify it.\n * @example\n *  // Register a constructor with `toFRON` and `fromFRON` methods.\n *  register(User);\n * \n *  // Register a constructor and merger a customized prototype.\n *  register(Date, { toFRON() { ... }, fromFRON() { ... } });\n * \n *  // Register a non-constructor type with a customized prototype.\n *  register(\"Article\", { toFRON() { ... }, fromFRON() { ... } });\n * \n *  // Four ways to register an alias type.\n *  // NOTE: the former two will use the constructor `Student`\n *  // to create instance when parsing, but the last two will\n *  // use `User` since \"Student\" is not a constructor. However,\n *  // they all use the name \"Student\" as notation.\n *  register(Student, User);\n *  register(Student, \"User\");\n *  register(\"Student\", User);\n *  register(\"Student\", \"User\");\n */\nexport function register(\n    type: string | FRONConstructor | (new (...args: any[]) => any),\n    proto?: string | FRONConstructor | FRONEntry\n): void {\n    if (typeof type === \"function\") {\n        if (!proto) {\n            checkProto(type.name, type.prototype);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"string\") {\n            checkType(proto);\n            copyProto(CompoundTypes[proto], type);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"function\") {\n            checkProto(proto.name, proto.prototype);\n            copyProto(proto, type);\n            CompoundTypes[type.name] = type;\n        } else if (typeof proto === \"object\") {\n            checkProto(type.name, proto);\n            copyProto(proto, type);\n            CompoundTypes[type.name] = type;\n        } else {\n            throw new Error(`Invalid prototype: ${proto}`);\n        }\n    } else if (typeof type === \"string\") {\n        if (typeof proto === \"string\") {\n            checkType(proto);\n            CompoundTypes[type] = CompoundTypes[proto];\n        } else if (typeof proto === \"function\") {\n            checkProto(proto.name, proto.prototype);\n            CompoundTypes[type] = proto;\n        } else if (typeof proto === \"object\") {\n            checkProto(type, proto);\n            let ctor: Function = proto.constructor;\n\n            if (ctor === Object)\n                ctor = class extends FRONEntryBase { };\n\n            copyProto(proto, ctor);\n            CompoundTypes[type] = <any>ctor;\n        } else {\n            throw new Error(`Invalid prototype: ${proto}`);\n        }\n    } else {\n        throw new TypeError(`Invalid type: ${type}`);\n    }\n}\n\n/*********************** Register Well-Known Types ************************ */\n\n// Register handlers for Symbol.\nregister(<any>Symbol, {\n    toFRON(this: symbol) {\n        return Symbol.keyFor(this);\n    },\n    fromFRON(data: string) {\n        return Symbol.for(data);\n    }\n});\n\n// Register handlers for Number, Boolean, String.\n[Number, Boolean, String].forEach(type => {\n    register(type, {\n        toFRON(this: String | Number | Boolean) {\n            return this.valueOf();\n        },\n        fromFRON(data: any) {\n            return new (<any>this.constructor)(data);\n        }\n    });\n});\n\n// Register handlers for RegExp.\nregister(RegExp, {\n    toFRON(this: RegExp) {\n        return new FRONString(this.toString());\n    },\n    fromFRON(data: { source: string, flags: string }) {\n        // For FRON string to support object wrapped by RegExp, and literal is \n        // internally support by the parser.\n        return new (<any>this.constructor)(data.source, data.flags);\n    }\n});\n\n// Register handlers for Date.\nregister(Date, {\n    toFRON(this: Date) {\n        return this.toISOString();\n    },\n    fromFRON(data: string) {\n        return new (<any>this.constructor)(data);\n    }\n});\n\n// Register handlers for Map and Set.\n[Map, Set].forEach(type => {\n    register(type, {\n        toFRON(this: Iterable<any>) {\n            return values(this);\n        },\n        fromFRON(data: any[]) {\n            return new (<any>this.constructor)(data);\n        }\n    });\n});\n\n// Register handlers for typed arrays.\n[\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array\n].forEach(type => {\n    register(type, {\n        toFRON(this: Iterable<number>) {\n            return values(this);\n        },\n        fromFRON(data: number[]) {\n            return (<any>this.constructor).from(data);\n        }\n    });\n});\n\n// Register handlers for all errors.\n[\n    Error,\n    EvalError,\n    RangeError,\n    ReferenceError,\n    SyntaxError,\n    TypeError\n].forEach(type => {\n    register(type, {\n        toFRON(this: Error) {\n            // When stringify an error, stringify all its member properties,\n            // include `name`, `message` and `stack`, since they may not be \n            // enumerated, so using `pick()` to fetch them manually.\n            let reserved = [\"name\", \"message\", \"stack\"];\n\n            return Object.assign({}, pick(this, reserved), omit(this, reserved));\n        },\n        fromFRON(this: Error, data: { [x: string]: any }) {\n            Object.defineProperties(this, {\n                name: {\n                    value: data.name,\n                    writable: true,\n                    configurable: true\n                },\n                message: {\n                    value: data.message,\n                    writable: true,\n                    configurable: true\n                },\n                stack: {\n                    value: data.stack,\n                    writable: true,\n                    configurable: true\n                }\n            });\n            Object.assign(this, omit(data, [\"name\", \"message\", \"stack\"]));\n\n            return this;\n        }\n    });\n});\n\nif (IsNode) { // Register some well-known NodeJS types.\n    register(require(\"assert\").AssertionError, Error.name);\n    register(Buffer, Uint8Array.name);\n}","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nexports.string = require(\"./lib/string\");\nexports.number = require(\"./lib/number\");\nexports.keyword = require(\"./lib/keyword\");\nexports.regexp = require(\"./lib/regexp\");\nexports.comment = require(\"./lib/comment\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * @param {string} str \n * @param {string|string[]} excludes \n */\nfunction escape(str, excludes) {\n    return String(str).replace(/[\"'`\\\\\\b\\f\\n\\r\\t\\u2028\\u2029]/g, function (char) {\n        if (excludes && excludes.indexOf(char) >= 0)\n            return char;\n\n        switch (char) {\n            case '\"':\n            case \"'\":\n            case '`':\n            case \"\\\\\":\n                return \"\\\\\" + char;\n            case \"\\b\":\n                return \"\\\\b\";\n            case \"\\f\":\n                return \"\\\\f\";\n            case \"\\n\":\n                return \"\\\\n\";\n            case \"\\r\":\n                return \"\\\\r\";\n            case \"\\t\":\n                return \"\\\\t\";\n            case \"\\u2028\":\n                return \"\\\\u2028\";\n            case \"\\u2029\":\n                return \"\\\\u2029\";\n        }\n    });\n}\n\n/**\n * @param {string} str \n */\nfunction unescape(str) {\n    return String(str).replace(/\\\\[\"'`\\\\bfnrt]|\\\\u2028|\\\\u2029/g, function (chars) {\n        switch (chars) {\n            case '\\\\\"':\n            case \"\\\\'\":\n            case \"\\\\`\":\n            case \"\\\\\\\\\":\n                return chars[1];\n            case \"\\\\b\":\n                return \"\\b\";\n            case \"\\\\f\":\n                return \"\\f\";\n            case \"\\\\n\":\n                return \"\\n\";\n            case \"\\\\r\":\n                return \"\\r\";\n            case \"\\\\t\":\n                return \"\\t\";\n            case \"\\\\u2028\":\n                return \"\\u2028\";\n            case \"\\\\u2029\":\n                return \"\\u2029\";\n        }\n    });\n}\n\nexports.escape = escape;\nexports.unescape = unescape;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar KEYWORDS = /^\\s*(true|false|null|NaN|Infinity)(\\s*[,;)\\]}]|\\s*$)/;\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: true | false | null | NaN | Infinity }} \n */\nfunction parseToken(str) {\n    var match = KEYWORDS.exec(str);\n\n    if (match) {\n        var value;\n\n        switch (match[1]) {\n            case \"true\":\n                value = true;\n                break;\n            case \"false\":\n                value = false;\n                break;\n            case \"NaN\":\n            case \"Infinity\":\n                value = Number(match[1]);\n                break;\n            default:\n                value = null;\n                break;\n        }\n\n        return {\n            source: match[1],\n            offset: str.indexOf(match[1]),\n            length: match[1].length,\n            value: value\n        };\n    } else {\n        return null;\n    }\n}\n\n/**\n * @param {string} str \n */\nexports.parse = function parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n};\n\n/**\n * @param {true | false | null | NaN | Infinity} keyword\n */\nexports.toLiteral = function toLiteral(keyword) {\n    return String(keyword);\n};","import { stringify } from \"./stringify\";\nimport { parse, parseToken, composeToken, SourceToken } from \"./parse\";\nimport {\n    register,\n    FRONEntry,\n    FRONEntryBase,\n    FRONConstructor,\n    FRONString,\n    getType,\n    getInstance\n} from \"./types\";\n\nexport {\n    register,\n    stringify,\n    parse,\n    parseToken,\n    composeToken,\n    SourceToken,\n    FRONEntry,\n    FRONEntryBase,\n    FRONConstructor,\n    FRONString,\n    getType,\n    getInstance\n};","import get = require(\"get-value\");\nimport { string } from \"literal-toolkit\";\nimport { LatinVar } from \"./util\";\nimport {\n    CompoundTypes,\n    FRONString,\n    getType,\n} from './types';\n\n/** Stringifies any type of data in a common way. */\nfunction stringifyCommon(\n    data: any,\n    indent: string,\n    originalIndent: string,\n    path: string,\n    refMap: Map<any, string>\n): string {\n    let type = getType(data);\n\n    if (!type || type == \"function\") {\n        return;\n    } else if (type == \"null\") {\n        return type;\n    } else if (type == \"string\") {\n        return string.toLiteral(data);\n    } else if (type == \"Symbol\") {\n        return getHandler(type, indent, originalIndent, path, refMap)(data);\n    } else if (typeof data === \"object\") {\n        if (refMap.has(data)) {\n            // `Reference` is a special type in FRON, it indicates that the \n            // current property references to another property, they are \n            // `aliases` to each other. When stringifing, the first reached \n            // property will be transferred as usual, but other properties that \n            // reference to this property will only be notate as an `Reference` \n            // with the original path, and the parser can use that path to set\n            // property when parsing.\n            return \"Reference(\" + stringify(refMap.get(data)) + \")\";\n        } else {\n            refMap.set(data, path);\n            return getHandler(type, indent, originalIndent, path, refMap)(data);\n        }\n    } else {\n        return String(data);\n    }\n}\n\n/** Gets the handler to stringify the corresponding compound type. */\nfunction getHandler(\n    type: string,\n    indent: string,\n    originalIndent: string,\n    path: string,\n    refMap: Map<any, string>\n): (data: any) => string {\n    var handlers = {\n        \"Object\": (data: any) => {\n            let container: string[] = [];\n\n            if (typeof data.toFRON == \"function\") {\n                // If the given object includes a `toFRON()` method, call it and\n                // get the returning value as the data to be stringified.\n                data = data.toFRON();\n            }\n\n            if (data === undefined) return;\n\n            // Stringify all enumerable properties of the object.\n            for (let x in data) {\n                let isVar = LatinVar.test(x),\n                    prop = isVar ? x : `['${x}']`,\n                    res = stringifyCommon(\n                        data[x],\n                        indent + originalIndent,\n                        originalIndent,\n                        path + (isVar && path ? \".\" : \"\") + prop,\n                        refMap\n                    );\n\n                if (res === undefined)\n                    continue; // If the result returns undefined, skip it.\n                else if (indent)\n                    container.push((isVar ? x : stringify(x)) + `: ${res}`);\n                else\n                    container.push((isVar ? x : stringify(x)) + `:${res}`);\n            }\n\n            if (indent && container.length) { // use indentation\n                return \"{\\n\"\n                    + indent + container.join(\",\\n\" + indent) + \"\\n\"\n                    + indent.slice(0, -originalIndent.length) + \"}\";\n            } else {\n                return \"{\" + container.join(\",\") + \"}\";\n            }\n        },\n        \"Array\": (data: any[]) => {\n            let container: string[] = [];\n\n            // Only stringify iterable elements of the array.\n            for (let i = 0; i < data.length; i++) {\n                let res = stringifyCommon(\n                    data[i],\n                    indent + originalIndent,\n                    originalIndent,\n                    `${path}[${i}]`,\n                    refMap\n                );\n\n                // skip undefined result\n                (res !== undefined) && container.push(res);\n            }\n\n            if (indent && container.length) { // use indentation\n                return \"[\\n\"\n                    + indent + container.join(\",\\n\" + indent) + \"\\n\"\n                    + indent.slice(0, -originalIndent.length) + \"]\";\n            } else {\n                return \"[\" + container.join(\",\") + \"]\";\n            }\n        },\n    };\n\n    if (handlers[type]) {\n        return handlers[type];\n    } else {\n        return (data: any) => {\n            let handler: Function;\n\n            if (typeof data.toFRON == \"function\") {\n                // If the given object includes a `toFRON()` method, call it and\n                // get the returning value as the data to be stringified.\n                data = data.toFRON();\n            } else if (handler = get(CompoundTypes[type], \"prototype.toFRON\")) {\n                // If there is a customized handler registered to deal with the \n                // type, apply it to the data. The reason to call `apply()` \n                // instead of calling the method directly is that the handler \n                // method may not exist on the data instance, it may be \n                // registered with an object as prototype in the first place.\n                data = handler.apply(data);\n            } else {\n                // If no handler is found, stringify the data as an ordinary \n                // object with only its enumerable properties.\n                data = Object.assign({}, data);\n            }\n\n            if (data === undefined) {\n                return;\n            } else if (data instanceof FRONString) {\n                return data.valueOf();\n            } else {\n                return type + \"(\" + stringifyCommon(\n                    data,\n                    indent,\n                    originalIndent,\n                    path,\n                    refMap\n                ) + \")\";\n            }\n        }\n    }\n}\n\n/**\n * Stringifies the given data into a FRON string.\n * @param pretty The default indentation is two spaces, other than that, set \n *  any strings for indentation is allowed.\n */\nexport function stringify(data: any, pretty?: boolean | string): string {\n    let indent = \"\";\n\n    if (pretty) {\n        indent = typeof pretty == \"string\" ? pretty : \"  \";\n    }\n\n    return stringifyCommon(data, indent, indent, \"\", new Map<any, string>());\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\nvar escape = exports.escape = require(\"safe-string-literal\").escape;\nvar unescape = exports.unescape = require(\"safe-string-literal\").unescape;\n\nvar SINGLE_QUOTE = exports.SINGLE_QUOTE = \"'\";\nvar DOUBLE_QUOTE = exports.DOUBLE_QUOTE = '\"';\nvar BACK_QUOTE = exports.BACK_QUOTE = \"`\";\n\n/**\n * @param {string} str \n */\nfunction removeUnusedEscapes(str) {\n    var exludes = \"\\\\'\\\"`bfnrtux\";\n    return String(str).replace(/\\\\\\S/g, function (chars) {\n        if (!~exludes.indexOf(chars[1])) {\n            return chars[1];\n        } else {\n            return chars;\n        }\n    });\n}\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: string, quote: \"'\" | \"\\\"\" | \"`\" }} \n */\nfunction parseToken(str) {\n    var token = { source: \"\", offset: -1, length: 0, value: \"\", quote: \"\" };\n    var matches = \"\";\n    var skippedLength = 0;\n\n    for (var i = 0; i < str.length; i++) {\n        var char = str[i];\n\n        if (char != false || token.quote) {\n            if (token.offset === -1) {\n                token.offset = i;\n            }\n\n            token.source += char;\n\n            if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE || char === BACK_QUOTE) {\n                matches += char;\n\n                if (!token.quote) {\n                    token.quote = char;\n                } else if (char === token.quote && str[i - 1] !== \"\\\\\") {\n                    break;\n                }\n            } else if (char === \"\\\\\") {\n                if (str[i + 1] === \"\\n\") {\n                    token.source += \"\\n\";\n                    skippedLength += 2;\n                    i++; // skip new line character of the string\n                } else {\n                    matches += char;\n                }\n            } else if (char === \"\\n\") {\n                if (token.quote === BACK_QUOTE) {\n                    matches += char;\n                } else if (str[i - 1] !== \"\\\\\") {\n                    return null;\n                } else {\n                    matches = matches.slice(0, -1);\n                    matches += char;\n                }\n            } else if (char !== \"\\n\" && token.quote) {\n                matches += char;\n            } else {\n                return null;\n            }\n        }\n    }\n\n    // token.source = matches;\n    token.value = matches && unescape(removeUnusedEscapes(matches.slice(1, -1)));\n    token.length = matches.length + skippedLength;\n    token.offset = token.offset === -1 ? 0 : token.offset;\n\n    if (strictMatch(str, token, /^\\s*[,;:)\\]}\\/]|^\\s*$/)) {\n        return token;\n    } else {\n        return null;\n    }\n}\n\nexports.parse = parse;\n/**\n * @param {string} str \n */\nfunction parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n}\n\nexports.toLiteral = toLiteral;\n/**\n * @param {string} str \n * @param {\"'\" | \"\\\"\" | \"`\"} quote \n */\nfunction toLiteral(str, quote) {\n    var exclues;\n    quote = quote || '\"';\n\n    if (quote === \"'\")\n        exclues = '\"`';\n    else if (quote === '\"')\n        exclues = \"'`\";\n    else if (quote === \"`\")\n        exclues = \"'\\\"\\n\";\n\n    return quote + escape(str, exclues) + quote;\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\nvar keyword = require(\"./keyword\");\n\nvar NUM_SEQUENCE = \"0123456789abcdefox-+.\";\n\nexports.BIN = 2;\nexports.OCT = 8;\nexports.DEC = 10;\nexports.HEX = 16;\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @param {boolean} allowTrailings\n * @returns {{ source: string, offset: number, length: number, value: number, radix: 8 | 10 | 16 }} \n */\nfunction parseToken(str) {\n    var allowTrailings = arguments[1] || false;\n    var matches = \"\";\n    var token = { source: \"\", offset: -1, length: 0, value: NaN, radix: 0 };\n    var _token = keyword.parseToken(str);\n\n    if (_token) {\n        token = Object.assign(_token, { radix: 10 });\n\n        if (typeof token.value !== \"number\") {\n            return null;\n        }\n\n        return token;\n    }\n\n    for (var i = 0; i < str.length; i++) {\n        var char = str[i];\n\n        if (char != false || char === \"0\") {\n            if (token.offset === -1) {\n                token.offset = i;\n            }\n\n            var _char = char.toLowerCase();\n            var pos = NUM_SEQUENCE.indexOf(_char);\n\n            if (pos === -1) {\n                break;\n            } else if (_char === \"e\") {\n                if (token.radix === 16 || (\n                    token.radix === 10 && matches.indexOf(char) === -1)\n                ) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (_char === \"b\" || _char === \"o\" || _char === \"x\") {\n                if ((matches.length === 1 && matches[0] === \"0\") || (\n                    matches.length === 2 && matches[1] === \"0\" && (\n                        matches[0] === \"-\" || matches[0] === \"+\"\n                    )\n                )) {\n                    token.radix = ({ b: 2, o: 8, x: 16 })[_char];\n                    matches += char;\n                } else if (_char === \"b\" && token.radix === 16) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (pos < 8) {\n                if (matches.length === 0 || (\n                    matches.length === 1 && (\n                        matches[0] === \"-\" || matches[0] === \"+\"\n                    )\n                )) {\n                    if (char === \"0\") {\n                        token.radix = 8;\n                    } else {\n                        token.radix = 10;\n                    }\n                }\n                matches += char;\n            } else if (pos < 10) {\n                if (token.radix === 2 || token.radix === 8) {\n                    token.radix = 10;\n                }\n                matches += char;\n            } else if (pos < 16) {\n                if (token.radix === 16) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (char === \".\") {\n                if (matches.length === 0) {\n                    token.radix = 10;\n                    matches += char;\n                } else if (token.radix === 10 && matches.indexOf(\".\") === -1) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else { // -+\n                var prevChar = str[i - 1];\n                if (matches.length === 0 || ( // signed number\n                    prevChar === \"e\" || prevChar === \"E\" // scientific notation\n                )) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    token.source = matches;\n    token.length = matches.length;\n    token.offset = token.offset === -1 ? 0 : token.offset;\n\n    if (matches) {\n        if (token.radix === 8 && /[oO]/.test(matches) === false) {\n            token.value = parseInt(matches, 8);\n        } else if (token.radix !== 10) {\n            if (matches[0] === \"-\") {\n                token.value = -Number(matches.slice(1));\n            } else if (matches[0] === \"+\") {\n                token.value = Number(matches.slice(1));\n            } else {\n                token.value = Number(matches);\n            }\n        } else {\n            token.value = Number(matches);\n        }\n    }\n\n    var boundaries = token.radix === 10 ? /^\\s*[,;:)\\]}\\/]|^\\s*$/ : undefined;\n\n    if (isNaN(token.value) || (\n        !allowTrailings && !strictMatch(str, token, boundaries)\n    )) {\n        return null;\n    }\n\n    return token;\n}\n\nexports.parse = parse;\n/**\n * @param {string} str \n * @param {boolean} strict \n */\nfunction parse(str, strict) {\n    var token = parseToken(str, !strict);\n    return token ? token.value : undefined;\n}\n\nfunction isRadix(str, radix) {\n    var token = parseToken(str);\n    return token ? token.radix == radix : false;\n}\n\n/**\n * @param {string} str \n */\nexports.isBin = function isBin(str) {\n    return isRadix(str, 2);\n};\n\n/**\n * @param {string} str \n */\nexports.isOct = function isOct(str) {\n    return isRadix(str, 8);\n};\n\n/**\n * @param {string} str \n */\nexports.isDec = function isDec(str) {\n    return isRadix(str, 10);\n};\n\n/**\n * @param {string} str \n */\nexports.isHex = function isHex(str) {\n    return isRadix(str, 16);\n};\n\n/**\n * @param {string} str \n */\nexports.isNaN = function isNaN(str) {\n    var value = parse(str, true);\n    return value === undefined || Number.isNaN(value);\n};\n\n/**\n * @param {string} str \n */\nexports.isFinite = function isFinite(str) {\n    return Number.isFinite(parse(str, true));\n};\n\n/**\n * @param {number} num\n * @param {2 | 8 | 10 | 16} radix\n */\nexports.toLiteral = function toLiteral(num, radix) {\n    if (Number.isNaN(num) || num === Infinity) {\n        return keyword.toLiteral(num);\n    } else {\n        radix = radix || 10;\n        return ({ 2: \"0b\", 8: \"0o\", 10: \"\", 16: \"0x\" })[radix] + num.toString(radix);\n    }\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\n\nvar FLAGS = \"gimsuy\";\n\nexports.parseToken = parseToken;\n/**\n * \n * @param {string} str \n * @returns {{ source: string, offset: number, length: number, value: RegExp }}\n */\nfunction parseToken(str) {\n    var token = { value: null, offset: -1, length: 0 };\n    var source = \"\";\n    var flags = \"\";\n    var closed = false;\n\n    for (var i = 0; i < str.length; i++) {\n        var char = str[i];\n\n        if (char != false || source) {\n            if (token.offset === -1) {\n                token.offset = i;\n            }\n\n            if (char === \"/\") {\n                if (source.length === 0 || str[i - 1] === \"\\\\\") {\n                    source += char;\n                } else if (closed) {\n                    return null;\n                } else {\n                    source += char;\n                    closed = true;\n                }\n            } else if (source[0] !== \"/\") {\n                return null;\n            } else if (closed && FLAGS.indexOf(char) >= 0 && !~flags.indexOf(char)) {\n                flags += char;\n            } else if (!closed) {\n                source += char;\n            } else {\n                break;\n            }\n        }\n    }\n\n    token.source = source + flags;\n    token.offset = token.offset === -1 ? 0 : token.offset;\n    token.length = source.length + flags.length;\n\n    try {\n        token.value = new RegExp(source.slice(1, -1), flags);\n    } catch (e) {\n        return null;\n    }\n\n    if (!strictMatch(str, token)) {\n        return null;\n    }\n\n    return token;\n}\n\n/**\n * @param {string} str\n */\nexports.parse = function parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n};\n\n/**\n * @param {RegExp} re\n */\nexports.toLiteral = function toLiteral(re) {\n    return String(re);\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar INLINE_COMMENT = /^\\s*\\/\\/.*\\n*?/;\nvar MULTI_LINE_COMMENT = /^\\s*\\/\\*[\\s\\S]*?\\*\\//;\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: string, type: \"//\" | \"/*\" | \"/**\" }} \n */\nfunction parseToken(str) {\n    var token = { source: \"\", offset: 0, length: 0, value: \"\", type: \"\" };\n    var match = INLINE_COMMENT.exec(str) || MULTI_LINE_COMMENT.exec(str);\n\n    if (match) {\n        token.offset = match[0].indexOf(\"/\");\n        token.length = match[0].length - token.offset;\n        token.source = token.value = match[0].slice(token.offset);\n\n        if (token.value[1] === \"/\") {\n            token.type = \"//\";\n        } else if (token.value.slice(1, 3) === \"**\") {\n            token.type = \"/**\"\n        } else {\n            token.type = \"/*\";\n        }\n\n        return token;\n    } else {\n        return null;\n    }\n}\n\n/**\n * \n * @param {string} str \n * @param {boolean} strip Strip meaningless characters.\n */\nexports.parse = function parse(str, strip) {\n    var token = parseToken(str);\n\n    if (!token) return;\n\n    if (!strip) {\n        return token.value;\n    } else if (token.type === \"//\") {\n        return token.value.replace(/^\\/\\/\\s*/, \"\");\n    } else {\n        var lines = token.value.replace(/\\s*\\*\\/$/, \"\").split(\"\\n\");\n        var value = lines[0].replace(/^\\/\\*\\s*/, \"\");\n        var isNewLine = false;\n\n        for (var i = 1; i < lines.length; i++) {\n            if (/^[\\s\\*]*$/.test(lines[i])) {\n                if (!isNewLine) {\n                    value += \"\\n\";\n                    isNewLine = true;\n                }\n            } else {\n                value += (isNewLine ? \"\" : \" \") + lines[i].replace(/^[\\s\\*]*/, \"\");\n                isNewLine = false;\n            }\n        }\n\n        return value;\n    }\n};\n\n/**\n * @param {string} str\n * @param {\"//\" | \"/*\" | \"/**\"} type\n * @param {string} indent Indent all rest lines of the comment with the given spaces.\n */\nexports.toLiteral = function toLiteral(str, type, indent) {\n    type = type || \"//\";\n    indent = indent || \"\";\n\n    var hasMultiLine = str.indexOf(\"\\n\") >= 0;\n\n    if (!hasMultiLine) {\n        if (type === \"//\") {\n            return \"// \" + str;\n        } else {\n            return type + \" \" + str + \" */\";\n        }\n    } else {\n        var lines = str.split(\"\\n\");\n\n        if (type === \"//\") {\n            lines[0] = \"// \" + lines[0];\n        } else {\n            lines.unshift(type);\n        }\n\n        for (var i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].replace(/^\\s*/, \"\");\n\n            if (type == \"//\") {\n                lines[i] = indent + \"// \" + lines[i];\n            } else {\n                lines[i] = indent + \" * \" + lines[i];\n            }\n        }\n\n        if (type !== \"//\") {\n            lines.push(indent + \" */\");\n        }\n\n        return lines.join(\"\\n\");\n    }\n};","module.exports = require(\"assert\");","import get = require(\"get-value\");\nimport set = require(\"set-value\");\nimport { pick, last, normalize, LatinVar } from \"./util\";\nimport { CompoundTypes, getInstance } from \"./types\";\nimport {\n    LiteralToken,\n    string,\n    number,\n    regexp,\n    comment,\n    keyword\n} from 'literal-toolkit';\n\n/** A pattern to match Latin properties or type notations. */\nexport const TypeOrPorp = /^([a-z_][a-z0-9_]*)\\s*[:\\(]/i;\n\n/**\n * The interface that carries token details in the FRON string (source), e.g.\n * `filename`, `position`, `type` etc.\n */\nexport interface SourceToken {\n    /**\n     * The filename that parsed to the parser, if no filename is parsed, the \n     * default value will be `<anonymous>`.\n     */\n    filename: string;\n    /**\n     * The appearing position of the current token, includes both start and end \n     * positions.\n     */\n    position: {\n        start: {\n            line: number,\n            column: number\n        };\n        end: {\n            line: number,\n            column: number\n        };\n    };\n    /**\n     * The type of the current token, literal types are lower-cased and compound\n     * types are upper-cased.\n     */\n    type: string;\n    /**\n     * The parsed data of the current token, it may not be the final data since\n     * there may be a handler to deal with the current type.\n     */\n    data: any;\n    /** The token of the parent node. */\n    parent?: SourceToken;\n    /**\n     * The path of the current token, only for object properties and array \n     * elements.\n     */\n    path?: string;\n    /**\n     * All the comments in the current token. When parsing a comment token, it \n     * will be appended to the closest parent node, unless the comment is the \n     * very first token. Comments are not important to the parser and will be \n     * skipped when composing data.\n     */\n    comments?: SourceToken[];\n}\n\n/**\n * SourceToken is a class constructor as well, it is used to distinguish \n * the token object from all objects.\n */\nexport class SourceToken implements SourceToken {\n    constructor(token: SourceToken) {\n        Object.assign(this, token);\n    }\n}\n\n/** Carries details of the current position of the parsing cursor. */\nexport interface CursorToken {\n    index: number;\n    line: number;\n    column: number;\n    filename: string;\n}\n\n/**\n * Throws syntax error when the current token is invalid and terminate the \n * parser immediately.\n */\nexport function throwSyntaxError(token: SourceToken, char: string) {\n    let filename = token.filename,\n        type = token.type ? token.type + \" token\" : \"token \" + char,\n        { line, column } = token.position.start;\n    throw new SyntaxError(`Unexpected ${type} in ${filename}:${line}:${column}`);\n}\n\n/**\n * Gets the customized handler of the given type for parsing, may return \n * undefined if no handler is registered.\n */\nexport function getHandler(type: string): (data: any) => any {\n    return get(CompoundTypes[type], \"prototype.fromFRON\");\n}\n\n/** Parses every token in the FRON string. */\nfunction doParseToken(\n    str: string,\n    parent: SourceToken,\n    cursor: CursorToken,\n    listener?: (token: SourceToken) => void\n): SourceToken {\n    let char: string;\n    let token: SourceToken;\n\n    loop:\n    while ((char = str[cursor.index])) {\n        if (<any>char == false && char !== \"0\") {\n            // For falsy characters (except string '0'), only move the cursor \n            // forward, and do not parse any tokens.\n\n            cursor.index++;\n\n            if (char === \"\\n\") {\n                // Meet new line, increase the line number and move the column \n                // to the line head.\n                cursor.line++;\n                cursor.column = 1;\n            } else {\n                // Otherwise increase the column number only.\n                cursor.column++;\n            }\n\n            continue;\n        }\n\n        let remains: string,\n            dataToken: LiteralToken & { value: any, type?: string };\n\n        // Use a SourceToken instance, so that it could be distinguished from\n        // common objects.\n        token = new SourceToken({\n            filename: cursor.filename,\n            position: {\n                start: pick(cursor, [\"line\", \"column\"]),\n                end: undefined\n            },\n            type: undefined,\n            data: undefined,\n        });\n\n        // Using this method, so that the parent property won't be always showed\n        // up on the token.\n        if (parent) token.parent = parent;\n\n        switch (char) {\n            case \",\":\n                // A comma (`,`) appears right after a property value in an \n                // object, or an element in an array.\n                if (parent && [\"Object\", \"Array\"].indexOf(parent.type) >= 0) {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \":\":\n                // A colon (`:`) appears right after a property name in an \n                // object.\n                if (parent && parent.type === \"property\") {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \"(\":\n                // The open bracket (`(`) appears right after a compound type \n                // name, which will be parsed as an individual token, and the \n                // bracket only indicates that it's the beginning of the type \n                // container. A compound type notation uses a type name and a \n                // pair of brackets to form a container, inside the container, \n                // is an pure object literal or array literal.\n                // The parent here is the very type name node of the compound \n                // type notation.\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break;\n\n            case \")\":\n                // The closing bracket (`)`) indicates the end position of a \n                // compound type container, see above.\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++\n                } else {\n                    throwSyntaxError(token, char);\n                }\n\n                // Break the loop means the current node has been fully parsed,\n                // if the node is not yet fully parsed, should just break the \n                // switch block and continue parsing. Once a token has been \n                // fully parsed, break the loop and go to the end of the \n                // function for summary, gather and fill the token details. \n                break loop;\n\n            case \"{\": // object\n            case \"[\": // array\n                // Like the very JavaScript style, an object literal uses a pair\n                // of curly braces to contain key-value pairs, and an array\n                // literal uses a pair of square brackets to contain elements.\n                let isArray = char === \"[\";\n\n                cursor.index++;\n                cursor.column++;\n                token.type = isArray ? \"Array\" : \"Object\";\n                token.data = isArray ? [] : {};\n\n                // Objects and arrays contains sub-nodes (inner tokens), so \n                // recursively calling `doParseToken` to parse them before \n                // parsing continuing tokens. Since the cursor is a reference,\n                // not a copy, when parsing inner tokens and move the cursor, \n                // the outside node will follow the cursor, and keep parsing\n                // from where the inner nodes ends.\n                doParseToken(str, token, cursor, listener);\n                break loop;\n\n            case \"}\": // closing sign of an object\n            case \"]\": // closing sign of an array\n                if (parent) {\n                    cursor.index++;\n                    cursor.column++;\n                } else {\n                    throwSyntaxError(token, char);\n                }\n\n                // The closing bracket of an object or array indicates the \n                // \"block\" is finished, and should no longer try to parse \n                // remaining tokens since they don't belong to the object or the\n                // array. `doParseToken()` will try to parse remaining tokens\n                // once a former token is parsed, since we don't need to parse \n                // them, return immediately to prevent that happens. \n                return;\n\n            case \"'\": // single-quoted string\n            case '\"': // double-quoted string\n            case \"`\": // back-quoted string\n                // Once a token type has been identified, assign it to the token\n                // object immediately, so that when even the token is invalid \n                // and throw a syntax error, the error can still tell what kind \n                // of token that is.\n                token.type = \"string\";\n\n                if ((dataToken = string.parseToken(str.slice(cursor.index)))) {\n                    let lines = dataToken.source.split(\"\\n\");\n\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.line += lines.length - 1;\n\n                    if (lines.length > 1) {\n                        // If the string takes multiple lines, move the column \n                        // number to the end of the last line.\n                        cursor.column = last(lines).length + 1;\n                    } else {\n                        cursor.column += dataToken.length;\n                    }\n                } else {\n                    console.log(str.slice(cursor.index));\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n\n            case \"/\": // regular expression or comment\n                token.type = \"regexp\";\n                remains = str.slice(cursor.index);\n\n                if ((dataToken = regexp.parseToken(remains))) { // regexp\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if ((dataToken = comment.parseToken(remains))) { // comment\n                    token.type = \"comment\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n\n                    if (dataToken.type !== \"//\") {\n                        // Multi-line comment starts with `/*` or `/**`.\n                        let lines = dataToken.source.split(\"\\n\");\n                        cursor.line += lines.length - 1;\n\n                        if (lines.length > 1) {\n                            cursor.column = last(lines).length + 1;\n                        } else {\n                            cursor.column += dataToken.length;\n                        }\n                    }\n                } else {\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n\n            default:\n                remains = str.slice(cursor.index);\n                let matches: RegExpMatchArray;\n\n                if ((dataToken = number.parseToken(remains))) { // number\n                    token.type = \"number\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if ((dataToken = keyword.parseToken(remains))) { // keyword\n                    token.type = \"keyword\";\n                    token.data = dataToken.value;\n                    cursor.index += dataToken.length;\n                    cursor.column += dataToken.length;\n                } else if (matches = remains.match(TypeOrPorp)) {\n                    let lines = matches[0].split(\"\\n\"),\n                        key = matches[1];\n\n                    cursor.index += key.length;\n                    cursor.line += lines.length - 1;\n\n                    if (lines.length > 1) {\n                        // If there are new lines between the property (or type \n                        // name) and the colon(or open bracket), move the column\n                        // number to the head of the line.\n                        cursor.column = 1;\n                    } else {\n                        cursor.column += key.length;\n                    }\n\n                    if (last(matches[0]) === \":\") { // property\n                        token.type = \"property\";\n\n                        // A property can only appears inside an object.\n                        if (parent && parent.type === \"Object\") {\n                            token.data = key;\n                        } else {\n                            throwSyntaxError(token, char);\n                        }\n                    } else { // compound type\n                        token.type = key;\n\n                        if (!parent && token.type === \"Reference\") {\n                            // A reference type con only appears inside a \n                            // compound type (object, array or something else).\n                            throwSyntaxError(token, char);\n                        } else {\n                            token.data = doParseToken(\n                                str,\n                                token,\n                                cursor,\n                                listener\n                            );\n\n                            // Since the token of a customized compound type \n                            // contains an extra closing bracket \")\", and \n                            // potential spaces, using doParseToken() can let \n                            // the cursor travel through them.\n                            doParseToken(str, token, cursor);\n                        }\n                    }\n                } else {\n                    isFinite(Number(char)) && (token.type = \"number\");\n                    throwSyntaxError(token, char);\n                }\n                break loop;\n        }\n    }\n\n    token.position.end = pick(cursor, [\"line\", \"column\"]);\n\n    if (token.parent && token.type === \"comment\") {\n        token.parent.comments = token.parent.comments || [];\n        token.parent.comments.push(token);\n    } else if (token.parent && token.parent.type === \"Object\") { // object\n        let prop = token.data,\n            isVar = LatinVar.test(prop),\n            prefix = get(token, \"parent.parent.path\", \"\"),\n            path = isVar ? (prefix ? \".\" : \"\") + `${prop}` : `['${prop}']`;\n\n        // If the parent node is an object, that means the current node is a \n        // property node, should set the path and parse the property value as a\n        // child node.\n        token.path = (prefix || \"\") + path;\n        token.type = \"property\";\n\n        // Use a while block to parse the property value token, in case there \n        // are comments before the value node.\n        while (token.data = doParseToken(str, token, cursor, listener)) {\n            if (!token.data || token.data.type !== \"comment\") break;\n        }\n\n        // Append the current node to the parent node as a new property. \n        token.parent.data[prop] = token;\n    } else if (token.parent && token.parent.type === \"Array\") { // array\n        let prefix = get(token, \"parent.path\", \"\");\n\n        // If the parent node is an array, append the current node to the parent\n        // node as its element.\n        token.path = `${prefix}[${token.parent.data.length}]`;\n        token.parent.data.push(token);\n    }\n\n    // If there is a listener bound, call it to watch all parsing moments.\n    listener && listener.call(void 0, token);\n\n    if (token.parent && [\"Object\", \"Array\"].indexOf(token.parent.type) >= 0) {\n        // If the parent node is either object or array, try to parse remaining \n        // tokens as its properties (or elements).\n        return doParseToken(str, token.parent, cursor, listener);\n    } else {\n        return token;\n    }\n}\n\n/**\n * Composes all tokens (include children nodes) to a JavaScript object and \n * gather all references into a map.\n */\nfunction compose(token: SourceToken, refMap: { [path: string]: string }): any {\n    let data: any;\n\n    switch (token.type) {\n        case \"Object\":\n            data = {};\n            for (let prop in token.data) {\n                // Every property in an object token is also SourceToken, which\n                // should be composed recursively.\n                data[prop] = compose(token.data[prop].data, refMap);\n            }\n            break;\n\n        case \"Array\":\n            data = [];\n            for (let item of token.data) {\n                // Every element in an array token is also SourceToken, which\n                // should be composed recursively.\n                data.push(compose(item, refMap));\n            }\n            break;\n\n        case \"Reference\":\n            // The data contained by Reference is a SourceToken with string,\n            // which should be composed first before using it.\n            refMap[token.parent.path] = compose(token.data, refMap);\n            break;\n\n        default:\n            if (token.data instanceof SourceToken) {\n                let handle = getHandler(token.type),\n                    inst = getInstance(token.type);\n\n                data = compose(token.data, refMap); // try to compose first\n\n                // Try to call registered parsing handler to get expected data.\n                data = handle\n                    ? handle.call(inst || data, data)\n                    : data;\n            } else if (token.type !== \"comment\") {\n                data = token.data;\n            }\n            break;\n    }\n\n    return data;\n}\n\n/** Composes a token or token tree to a JavaScript object. */\nexport function composeToken(token: SourceToken): any {\n    let refMap = {},\n        data = compose(token, refMap);\n\n    // Sets all references according to the map.\n    for (let path in refMap) {\n        let target = refMap[path];\n        let ref = target ? get(data, target) : data;\n        set(data, path, ref);\n    }\n\n    return data;\n}\n\n/**\n * Parses the given FRON string into a well-constructed token or token tree.\n * @param filename When parsing data from a file, given that filename to the \n *  parser, so that if the parser throws syntax error, it could address the \n *  position properly. The default value is `<anonymous>`.\n * @param listener If set, it will be called when parsing every token in the \n *  FRON string, and be helpful for programmatic usage.\n */\nexport function parseToken(\n    str: string,\n    filename?: string,\n    listener?: (token: SourceToken) => void\n): SourceToken {\n    return str ? doParseToken(str, null, {\n        index: 0,\n        line: 1,\n        column: 1,\n        filename: filename ? normalize(filename) : \"<anonymous>\"\n    }, listener) : null;\n}\n\n/**\n * Parses the given FRON string to JavaScript object.\n * @param filename When parsing data from a file, given that filename to the \n *  parser, so that if the parser throws syntax error, it could address the \n *  position properly. The default value is `<anonymous>`.\n */\nexport function parse(str: string, filename?: string): any {\n    return str ? composeToken(parseToken(str, filename)) : void 0;\n}","/*!\n * set-value <https://github.com/jonschlinkert/set-value>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst isPlain = require('is-plain-object');\n\nfunction set(target, path, value, options) {\n  if (!isObject(target)) {\n    return target;\n  }\n\n  let opts = options || {};\n  const isArray = Array.isArray(path);\n  if (!isArray && typeof path !== 'string') {\n    return target;\n  }\n\n  let merge = opts.merge;\n  if (merge && typeof merge !== 'function') {\n    merge = Object.assign;\n  }\n\n  const keys = isArray ? path : split(path, opts);\n  const len = keys.length;\n  const orig = target;\n\n  if (!options && keys.length === 1) {\n    result(target, keys[0], value, merge);\n    return target;\n  }\n\n  for (let i = 0; i < len; i++) {\n    let prop = keys[i];\n\n    if (!isObject(target[prop])) {\n      target[prop] = {};\n    }\n\n    if (i === len - 1) {\n      result(target, prop, value, merge);\n      break;\n    }\n\n    target = target[prop];\n  }\n\n  return orig;\n}\n\nfunction result(target, path, value, merge) {\n  if (merge && isPlain(target[path]) && isPlain(value)) {\n    target[path] = merge({}, target[path], value);\n  } else {\n    target[path] = value;\n  }\n}\n\nfunction split(path, options) {\n  const id = createKey(path, options);\n  if (set.memo[id]) return set.memo[id];\n\n  const char = (options && options.separator) ? options.separator : '.';\n  let keys = [];\n  let res = [];\n\n  if (options && typeof options.split === 'function') {\n    keys = options.split(path);\n  } else {\n    keys = path.split(char);\n  }\n\n  for (let i = 0; i < keys.length; i++) {\n    let prop = keys[i];\n    while (prop && prop.slice(-1) === '\\\\' && keys[i + 1]) {\n      prop = prop.slice(0, -1) + char + keys[++i];\n    }\n    res.push(prop);\n  }\n  set.memo[id] = res;\n  return res;\n}\n\nfunction createKey(pattern, options) {\n  let id = pattern;\n  if (typeof options === 'undefined') {\n    return id + '';\n  }\n  const keys = Object.keys(options);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    id += ';' + key + '=' + String(options[key]);\n  }\n  return id;\n}\n\nfunction isObject(val) {\n  switch (typeof val) {\n    case 'null':\n      return false;\n    case 'object':\n      return true;\n    case 'function':\n      return true;\n    default: {\n      return false;\n    }\n  }\n}\n\nset.memo = {};\nmodule.exports = set;\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n"],"sourceRoot":""}